[["index.html", "Analysis Methods for Complex Data Structures: Spatial Data Overview Learning outcomes Teaching structure Computational notebooks Contact", " Analysis Methods for Complex Data Structures: Spatial Data Mark Green 2021-10-15 Overview The resource here is part of the University of Liverpool module: DASC507 – Advanced Biostatistics II: Analysis Methods for Complex Data Structures Specifically, the resources contained here are for the ‘Spatial Data’ part of the module. In the following four sessions we will explain how to deal with spatial data, visualise them, and introduce some techniques for analysising spatial data. Learning outcomes Produce static and interactive visualisations of spatial data. Identify clustering of point- and area-based data. Extend regression-based approaches to incorporate spatial context. Teaching structure There are a total of eight sessions as part of the spatial data component of the module. This contains four lectures, which will be short talks introducing concepts and applications within each technique, and four supplementary practicals that will cover how to implement the same techniques within R. The resources here cover the practical sessions, although links to the lecture slides are also provided at the relevant places. Computational notebooks The materials for the practical sessions are embedded within R notebooks. Notebooks are interactive documents that allow for executionable code to be embedded within for running analyses (and presenting their outputs within the same document). They are helpful for teaching, since you can combine analytical code, the resulting output, and interpretation of what was done in a single file. All of the data and scripts are included within the folder structure, meaning that everything should be fully replicatable. Follow the documents along, reading the guidance and testing parts of the code. Feel free to edit the documents and code as you learn, so that you can have one single resource. The easiest way to access all the files to replicate the analyses on your own computer is to download the course zip file from Github here. You can load the .Rmd files into RStudio and play around with files directly. If you follow the .Rmd files directly, then you can read through their interpretation and run the code locally too. Each package we use in the tutorials will need to be pre-installed. To install any package within R, please use install.packages(\"\") and specify the package name in-between \"\". Good R practice is to load all dependencies/packages at the start of any script, however for the purpose of these tutorials we will load each as and when we need them so that you can see when and where they are required. The course materials are all written using the bookdown package (Xie 2021), which was built on top of R Markdown and knitr (Xie 2015). Contact Dr Mark A. Green Senior Lecturer in Health Geography University of Liverpool mark.green@liverpool.ac.uk References "],["whymap.html", "Chapter 1 Mapping data 1.1 Why map? 1.2 Mapping in R 1.3 Interactive maps 1.4 Summary", " Chapter 1 Mapping data In this section, we will introduce how to map and visualise spatial data in R. It will introduce you to the key R packages for wrangling and plotting spatial data, and demonstrate how to use them for different data types. The lecture slides for this practical can be found here: powerpoint or pdf. 1.1 Why map? Geography is the lens at which we view the World. Through exploring how health outcomes vary between neighbourhoods, cities or regions, as well as their drivers, we can start to piece together the underlying processes affecting health. Visualisations allow us to make data ‘real’ and can give us an intuitive sense of what is going on. Maps are data visualisations that have an inherent spatial dimension to them. 1.2 Mapping in R There are several R packages that allow us to map and visualise data within R - too many to cover in just one module! Here we will focus on the three main packages for mapping vector data. Raster data are less common in public health, social science and health-related data science (satellite-derived measures, such as green space coverage or sensor estimated pollution, are the exceptions here). As such, we will not cover how to map them here. You can review the lecture slides over these data types here. In brief, vector data refer to points, lines or polygons (shapes representing areas) First, we have sf (Simple Features) which provides allows R to engage with spatial data and therefore is key for any wrangling of spatial data we need to do. Through base R’s plot() command, we can map data. We need sf for most spatial packages or commands, so it is core here. I find plot() somewhat restrictive in designing pretty or engaging visualisations. It is quick to run and requires minimal code, so often offers a ‘first pass’ at looking at the data Second, ggplot2 (Grammar of Graphics for Plotting v2) is one way of plotting data and producing professional-style visualisations. Plots are built sequentially, adding features one line at a time. It can be a bit ‘fiddly’ to learn, but once you understand how it works it can offer a great deal of customisation. We will focus on ggplot2 for most of our tutorials. Finally, tmap (Thematic Maps) is a package built primarily for mapping spatial data. The format follows a similar style to ggplot2. I find it easier to use for creating quick maps, but is less flexible than compared to ggplot2 when changing specific aspects of plots. It is probably personal perference which you will end up using. We will now go through how to use these packages to plot different types of vector data to sneak in introduce the key concepts of mapping. 1.2.1 Areas We first start with mapping data for areas. This may include information on neighbourhoods, cities, regions or countries - much health data is made available for areas and so this is a useful way of visualising health data. Data on individuals are often aggregated to geographical zones to make sure they are less disclosive as well. Spatial data are not stored in common data formats we may have encountered elsewhere (e.g., csv or text files). They require formats that can recognise their spatial nature, so that we can plot their geographical patterns clearly. One of the main types of storing spatial data are shapefies (.shp and associated files). Other file type formats for vector data include .GeoJSON (Geographic JavaScript Object Notation), .gml (Geography Markup Language), .kml (Google Keyhole Markup Language) and .gpx (GPS eXchange Format). We will stick with shapefiles for the purpose of this tutorial. Let’s have a look at some area data. We will load in small areas for Liverpool, specifically Middle Super Output Areas (MSOAs). MSOAs are statistical zones ucreated for the purpose of mapping administrative data. They represent ~7500 individuals and therefore represent large neighbourhoods to small towns/large villages. For most Census-based UK shapefiles, we can find them at UK Borders. You can find the data themselves stored in the Shapefiles folder. We will also load the R package sf so that R can handle these data. library(sf) # Load in sf package ## Registered S3 methods overwritten by &#39;tibble&#39;: ## method from ## format.tbl pillar ## print.tbl pillar ## Linking to GEOS 3.7.2, GDAL 2.4.2, PROJ 5.2.0 msoas &lt;- read_sf(&quot;./Shapefiles/Liverpool_MSOAs/england_msoa_2011.shp&quot;) # Load in shapefile You may have noticed that we only need to load in a single file - the shapefile - and not the other files in the folder. This is because they each store supplementary information that helps R know how to interpret the shapefile (e.g., the projection of the data). Vector data are plotted based on their coordinate reference system (CRS). The CRS gives the spatial location of the data we are plotting. These are typically points and through joining up points we can create lines or polygons. They usually have two values representing the ‘x’ (longitude - the East to West location with respect to the distance from the ‘Prime Meridian’) and ‘y’ (latitude - the North to South location with respect to distance from the ‘Equator’) values of where they are. How ‘distance’ is measured is important and is what the CRS tell us. As the World is ellipsoidal (it is not quite spherical), and our computer screens are flat we need to tell R how to convert these values between the two formats. Essentially, we need to use projections to convert the three-dimensional geographic location onto a two-dimensional device. This process leads to some distortion of area size, direction, distance or shape. Selecting an appropriate projection is therefore important for plotting data and avoiding misleading visualisations. Different countries have different preferred projections. Fortunately, most spatial data is provided with a CRS. Using sf we can identify a CRS using st_crs(). st_crs(msoas) ## Coordinate Reference System: ## User input: 27700 ## wkt: ## PROJCS[&quot;OSGB 1936 / British National Grid&quot;, ## GEOGCS[&quot;OSGB 1936&quot;, ## DATUM[&quot;OSGB_1936&quot;, ## SPHEROID[&quot;Airy 1830&quot;,6377563.396,299.3249646, ## AUTHORITY[&quot;EPSG&quot;,&quot;7001&quot;]], ## TOWGS84[446.448,-125.157,542.06,0.15,0.247,0.842,-20.489], ## AUTHORITY[&quot;EPSG&quot;,&quot;6277&quot;]], ## PRIMEM[&quot;Greenwich&quot;,0, ## AUTHORITY[&quot;EPSG&quot;,&quot;8901&quot;]], ## UNIT[&quot;degree&quot;,0.0174532925199433, ## AUTHORITY[&quot;EPSG&quot;,&quot;9122&quot;]], ## AUTHORITY[&quot;EPSG&quot;,&quot;4277&quot;]], ## PROJECTION[&quot;Transverse_Mercator&quot;], ## PARAMETER[&quot;latitude_of_origin&quot;,49], ## PARAMETER[&quot;central_meridian&quot;,-2], ## PARAMETER[&quot;scale_factor&quot;,0.9996012717], ## PARAMETER[&quot;false_easting&quot;,400000], ## PARAMETER[&quot;false_northing&quot;,-100000], ## UNIT[&quot;metre&quot;,1, ## AUTHORITY[&quot;EPSG&quot;,&quot;9001&quot;]], ## AXIS[&quot;Easting&quot;,EAST], ## AXIS[&quot;Northing&quot;,NORTH], ## AUTHORITY[&quot;EPSG&quot;,&quot;27700&quot;]] You can see that the CRS used is 1936 British National Grid - a common CRS for files from Great Britain. To re-project any spatial data to a specific CRS, we can use the following command st_transform(). Let’s plot the spatial data usig sf and plot(). plot(msoas) Here we can see each MSOA’s location in Liverpool. Three maps are presented - one for each column in the shapefile. This is one reason why plot() is not useful, since it will just plot everything. Here is it is just plotting the descriptors of each MSOA (name = name of MSOA, code/label = unique code of MSOA). You can inspect the data yourself through using head(msoas). Mapping the MSOAs themselves is a little boring, so let’s join on some data. We will map COVID-19 vaccine uptake data for Liverpool - specifically the numbers of people who had receiveda vaccination between 8th December 2020 to 6th June 2021. The data are open and can be found here. I have cleaned the original file and saved it in Data folder. The variables we have are: msoa_code - unqiue code for each MSOA msoa_name - the name of each area total_first_dose - the number of people who received their first COVID-19 vaccine dose total_second_dose - the number of people who received two COVID-19 vaccine doses We will now load in the data and join it onto the shapefile. To do the latter step, we will need to join on a common identifier - in this case MSOA code as it is unique and allows us to assign a one-to-one match between datasets. The merge command can join together files, as long as we tell R on what files to join based on (i.e., which columns are the MSOA codes found). vaccine_uptake &lt;- read.csv(&quot;./Data/msoa_vaccine_10June21.csv&quot;) # Load in vaccine uptake data msoas &lt;- merge(msoas, vaccine_uptake, by.x = &quot;code&quot;, by.y = &quot;msoa_code&quot;, all.x = TRUE) # Merge the vaccine uptake objects onto the msoa object, based on the columns defined (x = msoas, y = vaccine_uptake), and do this for all observations only in the x (msoas) object You should always quickly check whether it worked. I usually run a brief head(msoas) check to see if it works. First, we will plot the number of people who have received their first dose of the COVID-19 vaccine. We will do this using ggplot2 library(ggplot2) # Load in package map1_1 &lt;- ggplot() + # Call ggplot command geom_sf(data = msoas, aes(fill = total_first_dose)) # Using a spatial object, plot MSOAs and fill in based on number of people with first COVID-19 dose map1_1 # Print plot Well done - you’ve made your first map! What patterns can you see? What might explain these patterns? We can edit the map to make it nicer, how about trying the following options. Remember that ggplot adds each feature line-by-line, so the order of your code sometimes matters to how it is plotted. library(viridis) # For colour blind friendly colours ## Loading required package: viridisLite map1_1 &lt;- ggplot() + # Call ggplot command geom_sf(data = msoas, aes(fill = total_first_dose), lwd = 0) + # Using a spatial object, plot MSOAs and fill in based on number of people with first COVID-19 dose, with line width = 0 (i.e., not visible) scale_fill_viridis_c(option = &quot;plasma&quot;) + # Make colour-blind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;First dose COVID-19 vaccinations&quot;, # Add title to map fill = &quot;Frequency&quot;) # Edit legend title map1_1 # Print plot Why not try editing some of the values above and see how it changes the aestheics of the map. To save the map, we use the following. ggsave(plot = map1_1, filename = &quot;./Plots/map1_ggplot.jpeg&quot;, dpi = 300) # save ## Saving 7 x 5 in image We next move onto plotting using tmap. Here we will plot the number of people who have had two doses of the COVID-19 vaccine. library(tmap) # Load package map1_2 &lt;- tm_shape(msoas) + # Call which spatial object tm_polygons(&quot;total_second_dose&quot;) # Which column to plot map1_2 # Print Just as easy to use! Again, let’s make the map prettier. We can also add in a few other common map conventions including a north arrow and a scale bar far easier with tmap. Note: calling viridis here can be a bit temperamental, and may need you to reload the package before running the code. map1_2 &lt;- tm_shape(msoas) + # Call which spatial object tm_polygons(&quot;total_second_dose&quot;, palette = &quot;viridis&quot;, title = &quot;Frequency&quot;) + # Which column to plot and plot using colour blind friendly colours and edit legend to &#39;Frequency&#39; tm_layout(main.title = &quot;Second dose uptake&quot;) + # Add title tm_scale_bar(position = c(&quot;right&quot;, &quot;top&quot;), width = 0.15) + # Add scale bar tm_compass(position = c(&quot;left&quot;, &quot;top&quot;), size = 2) # Add north arrow map1_2 # Print To save the map, we do the following. tmap_save(map1_2, filename = &quot;./Plots/map2.jpeg&quot;, dpi = 300) # Save file ## Map saved to /Users/markagreen/Documents/GitHub/spatial_data/Plots/map2.jpeg ## Resolution: 1789.97 by 2463.729 pixels ## Size: 5.966566 by 8.212429 inches (300 dpi) And there you go - just like that you have learned how to plot in R using three different packages! Easy. 1.2.2 Points The next type of data we will consider are points. The area polygons we have just mapped are really a bunch of points connected by lines, so they are the building blocks of spatial data. However, they offer value by themselves for representing specific spatial positions (e.g., locations of health services). Point data may be supplied in a spatial data format, or can just be provided as a text/csv file with a list of spatial points recorded within. The latter format can make them a little easier to handle, although since they are missing their CRS we will need to define it ourselves. Let’s have a go at plotting some points. We will stick with the COVID-19 vaccination theme here. During the initial roll-out of vaccines, Liverpool City Council funded a ‘vaccination bus’ that could travel around Liverpool and make getting a vaccination more accessible (i.e., people could just turn up and get vaccinated there and then). Let’s have a look at the areas they brought the bus to. To load in the point locations of where the bus traveled to, we can treat the data as a standard data frame in R. bus_locations &lt;- read.csv(&quot;./Data/liverpool_bus_locations.csv&quot;) # Load data If we use head(bus_locations), we can inspect the data. It includes the following variables: site - name of the location visited longitude - the spatial location, as measured east-west of the Greenwich Meridian point latitude - the spatial location, as measured north-south of the Equator postcode - the postal address of the site (note that postcodes are not unique and may represent 15 households) location - latitude and longitude combined into a single geometry point The data is currently stored in a data frame format. We need to tell R that it is actually spatial data, so that it can plot it as such. sf can help us here. # Convert to spatial data frame bus_locations_sp &lt;- bus_locations %&gt;% # For object (bus locations) st_as_sf(coords = c(&quot;longitude&quot;, &quot;latitude&quot;)) %&gt;% # Define as spatial object and identify which columns tell us the position of points st_set_crs(4326) # Set CRS Let’s look at where these points are located. First, we will use ggplot2. map1_3 &lt;- ggplot() + # Call ggplot command geom_sf(data = bus_locations_sp, colour = &quot;green&quot;) + # Plot points as green dots xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Location of vaccine bus&quot;) # Edit legend title map1_3 # Print plot Hmmmm, that is not particularly useful by itself. Let’s add these points to the map of vaccine uptake that we made earlier. This will help us tell if the locations were targeted at areas with low or high uptake. Note that we call the points after the area data, since ggplot2 builds the plot sequentially, this helps to ensure the points are plotted on top of the area data. map1_3 &lt;- ggplot() + # Call ggplot command geom_sf(data = msoas, aes(fill = total_first_dose), lwd = 0) + # Plot vaccine uptake (1st dose) scale_fill_viridis_c(option = &quot;plasma&quot;) + # Make colour-blind friendly geom_sf(data = bus_locations_sp, colour = &quot;green&quot;) + # Plot points as green dots xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;First dose COVID-19 vaccinations&quot;, # Add title to map caption = &quot;Green dots are locations of vaccine bus&quot;, # Add description to bottom of map (alternatively could place as subtitle = &quot;&quot; too) fill = &quot;Frequency&quot;) # Edit legend title map1_3 # Print plot How useful do you think the vaccine bus locations are? Do you think this approach is helpful? How might you improve or better target their locations? We can do the same using tmap too. We next recreate the same map from earlier (2nd dose uptake) and compare it to vaccine bus locations. map1_4 &lt;- tm_shape(msoas) + # Call area data object tm_polygons(&quot;total_second_dose&quot;, palette = &quot;viridis&quot;, title = &quot;Frequency&quot;) + # Which column to plot and plot using colour blind friendly colours and edit legend to &#39;Frequency&#39; tm_shape(bus_locations_sp) + # Call spatial points tm_dots(size = 0.5) + # Plot points (cal call specific variable here too) tm_layout(main.title = &quot;Second dose uptake&quot;) + # Add title tm_scale_bar(position = c(&quot;right&quot;, &quot;top&quot;), width = 0.15) + # Add scale bar tm_compass(position = c(&quot;left&quot;, &quot;top&quot;), size = 2) # Add north arrow map1_4 # Print Here, we have to call two spatial objects and then tell tmap what to plot, which is a different approach to the ggplot2 code. 1.3 Interactive maps So far we have created ‘static’ maps. They are static in the sense that they do not move or change, which is important for print media (i.e., those printed in articles). It can be preferable to create interactive plots where users can actively engage with data. ggplot2 does not natively allow for interactive maps, however tmap does. All we have to do is tell tmap we want to create an interactive and clickable map, and then run our code from earlier. tmap_mode(&quot;view&quot;) # Set tmap to interactive plotting mode ## tmap mode set to interactive viewing map1_4 # Plot map object ## Compass not supported in view mode. ## Scale bar width set to 100 pixels # Alternatively, you can just run the code and it will create the interactive map on the fly - try running the following: # tm_shape(msoas) + # Call which spatial object # tm_polygons(&quot;total_second_dose&quot;, palette = &quot;RdYlBu&quot;) # Which column to plot, and change colour If you hover over points or areas, you will see there is a description of what they are (based on first column in the dataset, although this can be changed). You can also change the base map by clicking on the layers box to the left. This is also useful as you can plot multiple layers at once and switch between them. If you want to make static maps again, you will need to tell tmap this through running the following code tmap_mode(\"plot\"). We can also save these interactive maps as standalone html files that can be shared. tmap_save(map1_4, filename = &quot;./Plots/vaccine_bus_interactive.html&quot;) # Save ## Compass not supported in view mode. ## Scale bar width set to 100 pixels ## Interactive map saved to ./Plots/vaccine_bus_interactive.html We can edit the basemaps presented here to a range of options. A couple of my favourites include: Carto as basemap for tiles, rather than default of ESRI Stamen which is just pretty OpenStreetMap is always worth a shout Below is some code to try these styles, but you can inspect the range of designs and options here # # Carto - light # tm_basemap(leaflet::providers$CartoDB.PositronNoLabels, group = &quot;CartoDB basemap&quot;) + # Plot Carto basemap # tm_shape(msoas) + # Select MSOA object # tm_polygons(&quot;total_second_dose&quot;, palette = &quot;RdYlBu&quot;) + # Plot vaccine uptake (2nd dose) # tm_tiles(leaflet::providers$CartoDB.PositronOnlyLabels, group = &quot;CartoDB labels&quot;) # Plot place name labels # # Carto - dark # tm_basemap(leaflet::providers$CartoDB.DarkMatter) + # Plot Carto basemap # tm_shape(msoas) + # Select MSOA object # tm_polygons(&quot;total_second_dose&quot;, palette = &quot;RdYlBu&quot;) # # Stamen # tm_basemap(&quot;Stamen.Watercolor&quot;) + # Add Stamen as basemap # tm_shape(msoas) + # Select MSOA object # tm_polygons(&quot;total_second_dose&quot;, palette = &quot;RdYlBu&quot;) + # Plot vaccine uptake (2nd dose) # tm_tiles(&quot;Stamen.TonerLabels&quot;) # Adds labels for areas (e.g., place names) # # OpenStreetMap # tm_basemap(&quot;OpenStreetMap.HOT&quot;) + # Plot basemap # tm_shape(msoas) + # Select MSOA object # tm_polygons(&quot;total_second_dose&quot;, palette = &quot;RdYlBu&quot;) The eagled-eye of you may have noticed that this technology is enabled through something called leaflet. We can actually create interactive maps using leaflet directly, which gives greater flexibility and control (even if the code is longer and more difficult). Let’s give it a go! # Load package library(leaflet) # Transform the CRS to match WGS84 format for leaflet msoas &lt;- st_transform(msoas, 4326) # Define parameters for colours for mapping pal &lt;- colorNumeric(viridis_pal(option = &quot;viridis&quot;)(2), domain = c(0, 5000)) # Set doman as min/max # Plot leaflet() %&gt;% # Add area data on vaccine uptake populations addPolygons(data = msoas, # Define data fillColor = ~pal(total_second_dose), # Specify the variable to be plotted, with pal representing the colours to plot weight = 0, # Define how thick the lines will be opacity = 0, # How see through we want the lines to be (0%) fillOpacity = 0.5) %&gt;% # How see through we want areas coloured in to be (50%) # Add bus locations in addCircleMarkers(data = bus_locations_sp, # Define data radius = 1, # Only plot immediate location color = &quot;red&quot;) %&gt;% # Select colour to plot addProviderTiles(&quot;CartoDB.Positron&quot;) # Define base map, here as Carto 1.4 Summary Well done! You have learned how to visualise spatial data, make professionally looking maps, and think about how to effectively present information in static and interactive ways. In the next section, we will consider how to apply this spatial way of presenting data into more formal approaches of analysis. "],["cluster.html", "Chapter 2 Cluster analysis 2.1 Point data 2.2 Area data 2.3 Summary", " Chapter 2 Cluster analysis In this section, we will introduce how we can analyse spatial data including identifying clustering of data. We define clustering here as where data (locations, or high/low values) are geographically concentrated in particular areas and not evenly spread out. The lecture slides for this practical can be found here: powerpoint or pdf. 2.1 Point data There are numerous point-based methods including clustering algorithms, spatial scan metrics, and count regression models that we could talk about here - too much to cover in this section. Instead, we will focus on descriptive techniques for displaying point-based data. 2.1.1 Spatial histograms One of the first steps we might take in trying to see if our point data are spatially clustered is by plotting their locations. This may be important if we are looking at the locations of disease cases or outbreaks, allowing us to make inferences about clustering of diseases and the reasons behind this. In the example here, we will look at food outlets in Liverpool to assess if they are geographically concentrated in particular areas of Liverpool. We will first load in the data on locations of food outlets. The data are taken from the Food Standards Agency website here and are open data. While there are too many columns to describe here, it is worth familiarising yourself with all these columns using head(food_outlets) first. The key variables we will be using are: Geocode.Longitude - longitude for location of premises Geocode.Latitude - latitude for location of premises We also will load in the boundary shapefile for Liverpool here, to help provide a background for our points. library(sf) # Load package # Load food outlets data food_outlets &lt;- read.csv(&quot;./Data/liverpool_food_outlets.csv&quot;) # Load data food_outlets &lt;- food_outlets[!is.na(food_outlets$Geocode.Latitude),] # Drop missing co-ordinates (e.g., burger vans that have no fixed position) since cannot plot them # Convert to spatial points data frame food_outlets_sp &lt;- food_outlets %&gt;% # For object st_as_sf(coords = c(&quot;Geocode.Longitude&quot;, &quot;Geocode.Latitude&quot;)) %&gt;% # Define as spatial object and identify which columns tell us the position of points st_set_crs(4326) # Set CRS # Load Liverpool outline liverpool &lt;- read_sf(&quot;./Shapefiles/Liverpool_LAD/england_lad_2011.shp&quot;) # Load in shapefile liverpool &lt;- st_transform(liverpool, 4326) # Reproject to same as long/lat format Ok, with the data loaded in, we can now map the points. library(ggplot2) # Load package map1 &lt;- ggplot() + # Call ggplot command geom_sf(data = liverpool) + # Load liverpool outline geom_sf(data = food_outlets_sp) + # Plot food outlet as dots xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Food outlets in Liverpool&quot;) # Edit plot title map1 # Print plot Hmmmm, you may see there is an issue with interpretating this plot - many of the plots overlap each other making it difficult to determine underlying patterns. We therefore need a way of summarising this information. Histograms are useful plots for examining the distribution of single variables - we can apply them spatially by creating spatial histograms. To do this, we need to create spatial bins and then count how many points are in each of those bins. We use this binning approach when producing histograms for single variables (e.g., counting how many points exist at each value of a variable) and just extend it here for each x,y position on a map. I recommend using a hex approach, since hexagons can minimise visual artefacts that can be created through other shapes. library(viridis) # Load package map2 &lt;- ggplot() + # Call ggplot2 geom_sf(data = liverpool) + # Load liverpool outline geom_hex(data = food_outlets, aes(x = Geocode.Longitude, y = Geocode.Latitude)) + # Define data to be plotted scale_fill_viridis() + # Make colour blind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Food outlets in Liverpool&quot;) # Edit plot title map2 We can now see the clustering of points in the city centre, with food outlets covering most of the city. 2.1.2 Kernal Density Estimation An alternative approach might be to use Kernal Density Estimation (KDE) which can create a continuous surface for the density/clustering of points. This avoids the limitation of spatial histograms through creating a single map with no boundaries, rather than splitting up areas into arbitrary bins. KDE or density plots are often used as alternative to standard histograms. Here we are measuring the intensity or density of points for a given location. We can run these analyses in ggplot2 using the stat_density2d_filled command. map3 &lt;- ggplot() + # Call ggplot2 geom_sf(data = liverpool) + # Load liverpool outline stat_density2d_filled( # Call KDE or smoothed density plot data = food_outlets, aes(x = Geocode.Longitude, y = Geocode.Latitude, # Define data and locations fill = ..level..,alpha=..level..), # Set paramters for colouring in values n = 100 # Modify and see how changes the map (is number of neighbours to derive clustering from) ) + scale_color_viridis() + # Make colour blind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Food outlets in Liverpool&quot;) # Edit plot title map3 The resulting map is similar to the hexmap earlier, but we now have one contiguous and single surface for the data. It is worth playing about with the number of neighbours to examine how the algorithm changes the resulting map. Sometimes these are called ‘heatmaps.’ 2.1.3 Spatial interpolation Sometimes the point data that we have contain values or variables that tell us information about them. Here we might be interested in values themselves, rather than the clustering of their locations. We therefore need a different approach here. To demonstrate how to visualise and extract some value here, we will use a new dataset. The data can be found here and are open data. I have done some additional cleaning on the data and extracted their spatial locations to save us time. There is active debate over how useful these data are, but they provide a helpful case study. The variables in the dataset are: pcn_code - unique code for the primary care network (groups of GP practices/surgeries) pcn_name - name for primary care network gp_code - unique code for GP surgery gp_name - name of GP surgery chronic_heart_disease_percent - estimated percentage of people at the surgery who have chronic heart disease obese_percent - estimated percentage of people who are defined as obese postcode - postcode for GP surgery longitude - longitude location latitude - latitude location Let’s load in these data. # Load data gp_locations &lt;- read.csv(&quot;./Data/gp_qof_1920.csv&quot;) # Convert to spatial points data frame gp_locations_sp &lt;- gp_locations %&gt;% # For object st_as_sf(coords = c(&quot;longitude&quot;, &quot;latitude&quot;)) %&gt;% # Define as spatial object and identify which columns tell us the position of points st_set_crs(4326) # Set CRS There are numerous ways that we might plot or visualise these data. First, we could simply assign colours to each point based on their values. We will explore this using the data on percentage of registered patients who are obese. map4 &lt;- ggplot() + # Call ggplot2 geom_sf(data = liverpool) + # Plot Liverpool outline geom_sf(data = gp_locations_sp, aes(color = obese_percent), size = 2) + # Define what to map (adjusted size to make easier to see) scale_color_viridis() + # Make colour blind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Percentage of patients who are obese&quot;, # Edit plot title color = &quot;Obesity (%)&quot;) # Edit legend title (note must match color as that is what we are plotting) map4 This is a little hard to see general patterns, but follows what we learnt last week. A second approach would be to adjust the size of the dots in relation to their value. map5 &lt;- ggplot() + # Call ggplot2 geom_sf(data = liverpool) + # Plot Liverpool outline geom_sf(data = gp_locations_sp, aes(size = obese_percent),) + # Define what to map scale_color_viridis() + # Make colour blind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Percentage of patients who are obese&quot;, # Edit plot title size = &quot;Obesity (%)&quot;) # Edit legend title (note must match size as that is what we are plotting) map5 Adjusting the size of points can be visually more striking, but is also harder to interpret the exact values. It is easier for the human mind to judge differences in colour rather than differences in sizes of points. Try identifying locations that are grouped as 15 or 20 on the map - it’s hard! Since our maps only present data for the spatial points themselves, we may want to estimate what the data might be like inbetween points to help identify the area extent of clusters or general spatial patterns. Here, we would turn to spatial interpolation techniques that can create a continuous surface based on given point values. There are various spatial interpolation techniques that we can then use to fill in the gaps including inverse distance weighting or spatial kriging techniques. In this tutorial, we will just use non-linear splines to estimate values inbetween points. Splines are faster to run, but may give less precise results. The following code below runs the interpolation code and then sorts the data out to a format for mapping. We need a couple of new packages here - akima and reshape2 - although, we will only use them briefly so I will not describe them in detail. # Interpolate data library(akima) # Load package obese_interp &lt;- with(gp_locations, interp(x = longitude, y = latitude, z = obese_percent, duplicate = &quot;mean&quot;, linear = FALSE)) # Set parameters for spatial location, what to predict, how to deal with duplicate values (i.e., take the mean), and linear = FALSE means uses cubic splines # Data wrangling library(reshape2) # Load package pred_obese_df &lt;- melt(obese_interp$z, na.rm = TRUE) # Convert predicted values from a list (in wide format) to data frame (in long format) names(pred_obese_df) &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;obese_percent&quot;) # Rename columns # Sort out longitude values x &lt;- melt(obese_interp$x, na.rm = TRUE) # Convert longitude values from list format to data frame x &lt;- data.frame(row.names(x), x, row.names = NULL) # Save row values as column (these match up to melt values x) names(x) &lt;- c(&quot;x&quot;, &quot;longitude&quot;) # Rename columns pred_obese_df &lt;- merge(pred_obese_df, x, by = &quot;x&quot;, all.x = T) # Join on longitude values to their lookup values from the melt process rm(x) # Tidy # Sort out latitude values y &lt;- melt(obese_interp$y, na.rm = TRUE) # Convert longitude values from list format to data frame y &lt;- data.frame(row.names(y), y, row.names = NULL) # Save row values as column (these match up to melt values y) names(y) &lt;- c(&quot;y&quot;, &quot;latitude&quot;) # Rename columns pred_obese_df &lt;- merge(pred_obese_df, y, by = &quot;y&quot;, all.x = T) # Join on longitude values to their lookup values from the melt process rm(y) # Tidy Phew, that code was rather messy but it does get the job done (if you know a better way, let me know!). We can now plot it using a heat map. map6 &lt;- ggplot() + # Call ggplot2 geom_sf(data = liverpool) + # Plot Liverpool outline geom_tile(data = pred_obese_df, aes(x = longitude, y = latitude, fill = obese_percent)) + # Define what to map (interpolated values) scale_fill_viridis() + # Make colour blind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Estimated obesity prevalence&quot;, # Edit plot title fill = &quot;Obesity (%)&quot;) # Edit legend title (note must match fill as that is what we are plotting) map6 We should be careful in producing these maps, since we are estimating data inbetween points and the resulting maps may not be correct. For example, it makes an assumption that people go to their nearest GP surgery to where they live, which is not always true. We can see a cluster of high levels of obesity north of the city centre, which is a densely populated deprived area. However, there is a lot of variability in the data and it is a little messy. Hopefully at least it gives you can idea of how to use these techniques and what they can produce. Can you produce a similar map for chronic health disease prevalence? (tip: the variable required is gp_locations$chronic_heart_disease_percent). 2.2 Area data These techniques introduced for point-based data do not work with area data. However, we can utilise more powerful techniques to examine the existence of clustering in our data. We will utilise a new R package - spdep (Spatial Dependence). The package includes a range of functions that are useful for creating spatial weighting schemes which are useful for identifying the spatial structure of datasets, as well as some spatial analysis methods including the spatial autocorrelation measures we will use here. To highlight some of these techniques, we will return to the data on vaccination uptake from the previous tutorial. Let’s load in the data and remind ourselves of the spatial patterns it contained. # Get data ready msoas &lt;- read_sf(&quot;./Shapefiles/Liverpool_MSOAs/england_msoa_2011.shp&quot;) # Load in shapefile for Liverpool MSOAs vaccine_uptake &lt;- read.csv(&quot;./Data/msoa_vaccine_10June21.csv&quot;) # Load in vaccine uptake data msoas &lt;- merge(msoas, vaccine_uptake, by.x = &quot;code&quot;, by.y = &quot;msoa_code&quot;, all.x = TRUE) # Merge the vaccine uptake objects onto the msoa object, based on the columns defined (x = msoas, y = vaccine_uptake), and do this for all observations only in the x (msoas) object # Map map7 &lt;- ggplot() + # Call ggplot command geom_sf(data = msoas, aes(fill = total_first_dose), lwd = 0) + # Using a spatial object, plot MSOAs and fill in based on number of people with first COVID-19 dose, with line width = 0 (i.e., not visible) scale_fill_viridis_c(option = &quot;plasma&quot;) + # Make colour-blind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;First dose COVID-19 vaccinations&quot;, # Add title to map fill = &quot;Frequency&quot;) # Edit legend title map7 # Print plot 2.2.1 Global Moran’s I The first step we would want to take is to describe the overall extent of spatial clustering of any variable. To do this, we will calculate a global Moran’s I statistic that can tell us the extent of clustering of data. You can review the methodology behind this in the related lecture slides here. To be able to describe the clustering, we need to tell R about the spatial structure of our dataset. Specifically, we need to identify which areas are located next to each other (i.e., neighbours). As we are dealing with area (polygons) spatial data, we will define spatial neighbours based on which borders they match on. So if two areas share a common border, then we can define them as neighbouring each other. There are two ways of defining this process: Rook contiguity - only areas that share common borders/edges of some defined length Queen contiguity - all areas that touch each other are considered neighbours, even if the shared space is very small To calculate the spatial structuring of neighbouring areas, we run the following code. library(spdep) # Load package ## Loading required package: sp ## Loading required package: spData ## To access larger datasets in this package, install the spDataLarge package with: `install.packages(&#39;spDataLarge&#39;, ## repos=&#39;https://nowosad.github.io/drat/&#39;, type=&#39;source&#39;)` nb &lt;- poly2nb(msoas, queen = TRUE) # Calculate queen contiguity for areas (set queen = FALSE for rook contiguity) We now need to assign spatial weights to each area (polygon) based on the spatial structure of the data. These weights are important when we are calculating the average values of neighbours, but adjusting their values. lw &lt;- nb2listw(nb, style = &quot;W&quot;, zero.policy = TRUE) # Assign weights based on list of neighbours. Each neighbouring area is given an equal weighting (syle = &quot;W&quot;). Zero.policy = TRUE allows for areas with no neighbours. Now that we have weightings for each areas linked to its neighbours, we can calculate the global Moran’s I. Essentially, it is looking at the correlation between each area’s value and the average values for surrounding neighbours. This gives a crude descriptive value of the amount of clustering in our data - it is termed ‘global’ since it is an average for all areas. m1 &lt;- moran.test(msoas$total_first_dose, lw) # Calculate Moran&#39;s I m1 # Print result ## ## Moran I test under randomisation ## ## data: msoas$total_first_dose ## weights: lw ## ## Moran I statistic standard deviate = 1.5264, p-value = 0.06345 ## alternative hypothesis: greater ## sample estimates: ## Moran I statistic Expectation Variance ## 0.107062246 -0.016666667 0.006570535 There is a lot of output here, however we are really only interested in two things mostly. The Moran’s I statistic is 0.1070622. We interpret the estimated value was running between -1 and 1, where values closer to 1 suggest existence of spatial clustering, values of 0 suggesting no clustering (i.e., random), and values less than 0 suggesting evenly dispersed values (rare in the real world). Some rules of thumbs - a value of 0.3 would suggest low-moderate clustering, with values 0.5+ suggestung moderate to high clustering. A value of 0.1070622 suggests little evidence of clustering in the data. We can also consider the p-value to assess if the result is statistically significant notwithstanding the continued controversy on using p-values. A value of 0.0634541 suggests that the result is not statistically significant, lending further evidence towards a conclusion that there is little evidence of spatial clustering. To get a more accurate p-value, we should use Monte Carlo simulations to estimate it. Let’s try this, but this time looking at the clustering of second dose COVID-19 vaccinations. m2 &lt;- moran.mc(msoas$total_second_dose, lw, nsim = 1000) # Calculate Moran&#39;s I and simulate 1000 times permutations to give more accurate p-value m2 # Print result ## ## Monte-Carlo simulation of Moran I ## ## data: msoas$total_second_dose ## weights: lw ## number of simulations + 1: 1001 ## ## statistic = 0.30176, observed rank = 1001, p-value = 0.000999 ## alternative hypothesis: greater Here we find some evidence of clustering in the data, with a value of suggesting low to moderate clustering in the data. m2_plot &lt;- moran.plot(msoas$total_second_dose, listw = lw, plot = FALSE) # Save raw moran&#39;s I data (if run without saving as an object, it will plot in base R if you set plot = TRUE (default)- for our purposes, I have shown how to get it into ggplot2 as it looks nicer # Plot plot1 &lt;- ggplot(data = m2_plot, aes(x = x, y = wx)) + # Plot x (actual values) and wx (average for neighbours) geom_point() + # Scatter plot geom_smooth(method = &quot;lm&quot;) + # Line of best fit xlab(&quot;Number of second doses&quot;) + # Label x-axis ylab(&quot;Spatially lagged number of second doses&quot;) plot1 # Print plot ## `geom_smooth()` using formula &#39;y ~ x&#39; 2.2.2 Local Moran’s I If we find evidence of clustering overall, then the next step is to describe where this clustering exists. The global Moran’s I for number of second COVID-19 vaccine doses suggested some clustering of values, let’s explore where the clustering exists and the nature of it. Using a local Moran’s I, we can calculate the extent each area belongs to a cluster of high or low values. # Estimate metrics local_2nd &lt;- localmoran(x = msoas$total_second_dose, listw = lw) # Calculate local Moran&#39;s I # local_2nd &lt;- localmoran_perm((x = msoas$total_second_dose, listw = lw, nsim=499) # In case want to run more simulations to get a more accurate level of significance local_2nd_map &lt;- cbind(msoas, local_2nd) # Join estimates onto shapefile for MSOAs # Map map8 &lt;- ggplot() + geom_sf(data = local_2nd_map, aes(fill = Ii)) + # Plot local Moran&#39;s I statistic (z score) scale_fill_viridis() + # Make colour blind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Clustering of second dose uptake&quot;, # Edit plot title fill = &quot;Local Moran&#39;s I&quot;) # Edit legend title (note must match fill as that is what we are plotting) map8 # Plot The map tells us how different each area is to it’s surrounding areas , with areas with higher z-scores representing areas that are clustered by higher values in the surrounding areas, and lower scores the opposite (surrounded by lower values). The map suggests a cluster in the city centre area, as well as a less distinct one to the South East. To understand how meaningful these spatial patterns are, we can plot the p-values for areas. map9 &lt;- ggplot() + geom_sf(data = local_2nd_map, aes(fill = Pr.z...0.)) + # Plot local Moran&#39;s I statistic (z score) scale_fill_viridis() + # Make colour blind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Clustering of second dose uptake&quot;, # Edit plot title fill = &quot;p-value&quot;) # Edit legend title (note must match fill as that is what we are plotting) map9 # Plot What the map is missing is the nature of the clusters. We can say with some confidence that there is a cluster in the city centre for example, but we are not sure what this is a cluster of. We could compare manually to map7, however it would be useful to have a single map the brings together all of this information. To help contextualise the clustering analysis, we need to classify the local Moran’s I data to describe their patterns. # Data wrangling quadrant &lt;- vector(mode=&quot;numeric&quot;, length = nrow(local_2nd)) # Create blank object for storing results m_2nd &lt;- msoas$total_second_dose - mean(msoas$total_second_dose) # Centers each area around its mean (for variable under investigation) m_localmi &lt;- local_2nd[,1] - mean(local_2nd[,1]) # Centers areas on the local Moran&#39;s I values around the mean sig &lt;- 0.1 # Define statistical significance threshold (feel free to select more stringent values) # Populate the blank object with our classification of results quadrant[m_2nd &lt; 0 &amp; m_localmi &lt; 0] &lt;- 1 # Low-low: Lower than average raw value, lower than average surrounding areas quadrant[m_2nd &lt; 0 &amp; m_localmi &gt; 0] &lt;- 2 # Low-high: Lower than average raw value, higher than average surrounding areas quadrant[m_2nd &gt; 0 &amp; m_localmi &lt; 0] &lt;- 3 # High-low: Higher than average raw value, lower than average surrounding areas quadrant[m_2nd &gt; 0 &amp; m_localmi &gt; 0] &lt;- 4 # High-high: Higher than average raw value, higher than average surrounding areas quadrant[local_2nd[,5] &gt; sig] &lt;- 0 # Identify non-significant areas quadrant &lt;- factor(quadrant, levels = c(&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;)) # Define variable as factor (as distinct categories) local_2nd_map2 &lt;- cbind(msoas, quadrant) # Join data onto the original shapefile # Plot map10 &lt;- ggplot() + geom_sf(data = local_2nd_map2, aes(fill = quadrant)) + # Plot values scale_fill_manual(values = c(&quot;0&quot; = &quot;white&quot;, &quot;1&quot; = &quot;blue&quot;, &quot;2&quot; = rgb(0,0,1,alpha=0.4), &quot;3&quot; = rgb(1,0,0,alpha=0.4), &quot;4&quot; = &quot;red&quot;), labels = c(&quot;Insignificant&quot;, &quot;Low-low&quot;, &quot;Low-high&quot;, &quot;High-low&quot;, &quot;High-high&quot;), breaks = c(0, 1, 2, 3, 4), drop = FALSE) + # Show all values in legend labs(title = &quot;Clustering of second dose uptake&quot;, # Edit plot title fill = &quot;Clusters&quot;) + # Edit legend title (note must match fill as that is what we are plotting) xlab(&quot;Longitude&quot;) + # Add labels ylab(&quot;Latitude&quot;) map10 # Print This map is a common output in local Moran’s I analyses. It combines the raw data, clustering analysis and associated statistical significance into a single plot. We can see that in the city centre, we have a cluster of low vaccination uptake surrounded by areas with higher values. We then have two significant clusters to the East, representing clusters of higher uptake. 2.2.3 Getis-Ord Gi statistic An alternative clustering metric is the Getis-Ord Gi statistic. The Gi statistic is presented as a z-score, with positive values representing clusters of high values and negative values representing clusters of low values. We can calculate the Gi statistic using the following code. localGi &lt;- localG(msoas$total_second_dose, listw = lw) # Calculate Gi statistics for each MSOA (second dose total) As before, the power of the clustering metrics is seen when we map it. Let’s visualise the spatial pattern of clustering. # Wrangle data Gi_map &lt;- cbind(msoas, data.matrix(localGi)) # Join results onto shapefile names(Gi_map)[names(Gi_map) == &quot;data.matrix.localGi.&quot;] &lt;- &quot;gstat&quot; # Rename column # Map map11 &lt;- ggplot() + geom_sf(data = Gi_map, aes(fill = gstat)) + scale_fill_viridis() + # Make colour blind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Second dose uptake&quot;, # Edit plot title fill = &quot;Gi statistic&quot;) # Edit legend title (note must match fill as that is what we are plotting) map11 The map produced is both similar and different to the local Moran’s I. We see clustering in the city centre (younger populations) and north parts of Liverpool (more deprived communities), with higher vaccinate uptake in the more affluent South and South-East parts of the city. 2.3 Summary So far, you have learned how to use spatial data in R, visualise and map their patterns, and start to analyse the spatial patterns themselves. Next we will move onto spatial extensions of regression techniques. "],["spatreg.html", "Chapter 3 Spatial Regression 3.1 Exploring the data 3.2 Non-spatial regression 3.3 Selecting the right spatial model 3.4 Spatial lag model 3.5 Spatial error models 3.6 Summary", " Chapter 3 Spatial Regression So far we have learned how to visualise spatial data and explore if patterns display clustering of high/low values. However, what if we want to understand the predictors of spatial patterns? In this section, we extend regression techniques to incorporate the spatial structure of data. The lecture slides for this practical can be found here: powerpoint or pdf. 3.1 Exploring the data In this tutorial, we will focus on understanding geographical patterns in COVID-19 vaccination uptake. Our analysis will use data collected for Local Authorities Districts (LADs). LADs are large administrative areas that correspond to Local Government areas, typically equivalent to a city, large town or region. I have collected data on uptake of COVID-19 vaccines (split by number of first and second doses upto 17th June 2021 from here. We will focus on the percentage of people who have had their first vaccination dose as our outcome variable of interest here. I have also compiled a suite of explanatory and contextual variables to help understand patterns in vaccination uptake. These include: Population data was gathered to provde the denominator for our outcome variables. These data are for mid-year 2019 (~July) and were the most recent available statistics available at the time. Data were downloaded from here. Population density is also calculated using the population estimates based on the ratio of people to the size of the area. We use this variable to account for urban and rural differences in population (as a proxy). Median age was collected from the above population data, to account for the local age structure of areas since older groups could receive their vaccine at an earlier date. Ethnicity is measured in aggregated ethnic groups. This was selected because of evidence that some ethnic groups have been targeted with misinformation that may have put them off getting their vaccine. We use estimate population counts for 2019 from here. I cleaned the data and converted the population estimates into percentages for the purpose of our analyses. The following aggregated ethnic groups are available: White British, Other White, Black or Black British, Asian or Asian British, Other Ethnicity. For analyses, we will look at all groups other than White British as we hypothesise they may have the highest uptake rates. Deprivation was measured using the Index of Multiple Deprivation score (2019). The composite index is the most commonly used measure of deprivation used by researchers and policy officials. We include deprivation in our analyses as we hypothesise that uptake will be lower in more deprived areas. The data are openly available here. Let’s load the data into R and tidy it up. # Load package library(sf) # Load and clean spatial data lad_uk &lt;- read_sf(&quot;./Shapefiles/UK_LAD/Local_Authority_Districts_(December_2019)_Boundaries_UK_BFC.shp&quot;) # Load shapefile for Local Authority Districts (LADs) for UK (sorry but could not find only England version so need to convert to match data) lad_uk$country &lt;- substr(lad_uk$lad19cd, 0, 1) # Record first letter of LAD code (denotes country) lad_eng &lt;- lad_uk[lad_uk$country == &quot;E&quot;,] # Subset only English LADs # Tidy and join on explanatory variables lad_data &lt;- read.csv(&quot;./Data/LAD_vaccine_data.csv&quot;) # Load vaccine uptake and demographic data for England lad_eng &lt;- merge(lad_eng, lad_data, by.x = &quot;lad19cd&quot;, by.y = &quot;ltla_code&quot;, all.x = TRUE) # Join on both datasets lad_eng$pop_density &lt;- lad_eng$population / (lad_eng$st_areasha / 1000000) # Calculate population density (st_areashape is measured in metres^2 so need to convert to km^2 by dividing by 1,000,000) lad_eng$percent_first_dose &lt;- (lad_eng$total_first_dose / lad_eng$population) * 100 # Calculate outcome variable # Remove objects to save space rm(lad_uk, lad_data) The first step is to visualise our outcome variable and examine if there are any spatial patterns. Ideally we would age-standardise our outcome since older age groups were allowed to be vaccinated at early dates, but for simplicity we will stick with the raw percentage of uptake don’t have a go at my laziness. # Load packages library(ggplot2) library(viridis) # Plot map1 &lt;- ggplot() + # Call ggplot command geom_sf(data = lad_eng, aes(fill = percent_first_dose), lwd = 0) + # Define what to plot scale_fill_viridis() + # Make colourblind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;First dose uptake&quot;, # Edit plot title fill = &quot;Percent (%)&quot;) # Edit legend title map1 # Print plot What are the main spatial patterns that you can observe? There is lower uptake in urban areas, especially London, although many of these areas are small on the map due taking up smaller land mass. Else, there is probably not any other distinct spatial pattern. 3.2 Non-spatial regression If we wanted to understand why uptake was higher or lower in certain areas, we might use a regression model. If we focus on the standard OLS regression model, we utilise the following equation: \\[ y = X\\beta + \\epsilon \\] Here, we predict \\(y\\) as a function of a series of predictor \\(X\\) variables that we adjust their effects based on \\(\\beta\\) values and some measure of the error \\(\\epsilon\\). We can use an OLS regression model to help us explain patterns in uptake, based on our explanatory variables. model1 &lt;- lm(percent_first_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + pop_density, data = lad_eng) # Fit a linear regression model for the following equation (outcome ~ explanatory) summary(model1) # Print model results summary ## ## Call: ## lm(formula = percent_first_dose ~ median_age + Other_White + ## Mixed + Black + Asian + Other + mean_imd_score + pop_density, ## data = lad_eng) ## ## Residuals: ## Min 1Q Median 3Q Max ## -11.0686 -1.3129 -0.1212 1.2518 7.0054 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.203e+01 2.113e+00 15.155 &lt; 2e-16 *** ## median_age 8.150e-01 4.255e-02 19.155 &lt; 2e-16 *** ## Other_White -7.320e-02 4.555e-02 -1.607 0.1091 ## Mixed 4.014e-01 1.589e-01 2.526 0.0120 * ## Black -2.516e-01 5.138e-02 -4.896 1.58e-06 *** ## Asian 1.910e-02 2.139e-02 0.893 0.3724 ## Other -1.406e-01 1.100e-01 -1.278 0.2021 ## mean_imd_score -9.943e-02 1.925e-02 -5.166 4.31e-07 *** ## pop_density -2.440e-04 9.955e-05 -2.451 0.0148 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.287 on 308 degrees of freedom ## Multiple R-squared: 0.8612, Adjusted R-squared: 0.8576 ## F-statistic: 238.9 on 8 and 308 DF, p-value: &lt; 2.2e-16 Urgh, what ugly output. I mean it is functional, but not pretty. Good thing we can make the output nicer using various packages in R. I really like gtsummary which can clean regression tables up. library(gtsummary) # Load package tbl_model1 &lt;- tbl_regression(model1, label = list(median_age ~ &quot;Median age&quot;, Other_White ~ &quot;Other White (%)&quot;, Mixed ~ &quot;Mixed (%)&quot;, Black ~ &quot;Black (%)&quot;, Asian ~ &quot;Asian (%)&quot;, Other ~ &quot;Other Ethnicity (%)&quot;, mean_imd_score ~ &quot;Deprivation score&quot;, pop_density ~ &quot;Population density&quot;)) # Make tidy table tbl_model1 # Print html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #gsmlykpuhb .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #gsmlykpuhb .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #gsmlykpuhb .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #gsmlykpuhb .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #gsmlykpuhb .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #gsmlykpuhb .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #gsmlykpuhb .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #gsmlykpuhb .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #gsmlykpuhb .gt_column_spanner_outer:first-child { padding-left: 0; } #gsmlykpuhb .gt_column_spanner_outer:last-child { padding-right: 0; } #gsmlykpuhb .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #gsmlykpuhb .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #gsmlykpuhb .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #gsmlykpuhb .gt_from_md > :first-child { margin-top: 0; } #gsmlykpuhb .gt_from_md > :last-child { margin-bottom: 0; } #gsmlykpuhb .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #gsmlykpuhb .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #gsmlykpuhb .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #gsmlykpuhb .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #gsmlykpuhb .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #gsmlykpuhb .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #gsmlykpuhb .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #gsmlykpuhb .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #gsmlykpuhb .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #gsmlykpuhb .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #gsmlykpuhb .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #gsmlykpuhb .gt_sourcenote { font-size: 90%; padding: 4px; } #gsmlykpuhb .gt_left { text-align: left; } #gsmlykpuhb .gt_center { text-align: center; } #gsmlykpuhb .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #gsmlykpuhb .gt_font_normal { font-weight: normal; } #gsmlykpuhb .gt_font_bold { font-weight: bold; } #gsmlykpuhb .gt_font_italic { font-style: italic; } #gsmlykpuhb .gt_super { font-size: 65%; } #gsmlykpuhb .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Characteristic Beta 95% CI1 p-value Median age 0.81 0.73, 0.90 Other White (%) -0.07 -0.16, 0.02 0.11 Mixed (%) 0.40 0.09, 0.71 0.012 Black (%) -0.25 -0.35, -0.15 Asian (%) 0.02 -0.02, 0.06 0.4 Other Ethnicity (%) -0.14 -0.36, 0.08 0.2 Deprivation score -0.10 -0.14, -0.06 Population density 0.00 0.00, 0.00 0.015 1 CI = Confidence Interval What does the model say? Median age was positively associated with the percentage of the population who were vaccinated, with areas that had older populations on average being associated with higher uptake. There are mixed associations found for the ethnicity variables - a negative association between the percentage of an area’s population that were Black or Black British and uptake (i.e., uptake was lower in areas with a higher share of the population that were Black), a positive association between Mixed ethnicity and uptake, and large uncertainty in estimates for ‘Asian,’ ‘Other White’ or ‘Other Ethnicity’ communities. Deprivation score was negatively associated with uptake, where as areas became more deprived uptake was lower. The effect for population density looks misleading in the cleaned table due to rounding issues, but if we scroll back up to the messier table we can see that as population density increases (i.e., larger more populated urban areas) uptake falls A few questions for you to think about: Was this the correct statistical model? Were the correct explanatory variables used and what happens if you try others? Does the same associations persist if we look at second dose uptake? One of the classical assumptions of an OLS regression model is the independence of errors (and to some extent observations as well). Since we have spatial data and areas closer together may be similar than those further apart (i.e., the characteristics and populations of Liverpool and Wirral are more similar than say, Liverpool and Guildford), this assumption may not hold. We can assess if this may be an issue through plotting the residuals (i.e., our error term \\(\\epsilon\\)) from the regression model and exploring if any spatial patterns exist. # Join on lad_eng &lt;- cbind(lad_eng, model1$residuals) # Plot map2 &lt;- ggplot() + # Call ggplot command geom_sf(data = lad_eng, aes(fill = model1.residuals), lwd = 0) + # Define what to plot scale_fill_viridis() + # Make colourblind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;First dose uptake model&quot;, # Edit plot title fill = &quot;Residuals&quot;) # Edit legend title map2 # Print plot If there were no issues here, we might expect to find a random pattern. However, we can see this isn’t always the case. A positive residual would suggest that the observed value of an area is greater than what the model would predict based on the coefficients and it’s local values for each explanatory variable. There are some clustering of values in the North West, London and other urban areas. Similarly, a negative value suggests lower observed uptake than we might expect/predict from the model. We can see evidence of this in the West and South East of England. Our analysis may therefore benefit from having a spatial regression model. 3.3 Selecting the right spatial model The first thing we might want to check is the extent that there is spatial clustering of our data. We will start here by checking this for our outcome variable and the regression model residuals. We will follow the same methods that we introduced in the previous session. We will need to identify the spatial structure of our dataset. We will follow the same previous method of assigning neighbouring areas based on Queen’s contiguity. One issue here is that we have two Local Authorities that are islands (Isles of Scilly and Isle of Wight) which do not have any neighbours. To solve this, we could either assign the two islands manually to their nearest ‘neighbour’ (e.g., Isles of Scilly to Cornwall) or remove them from our analysis. For the basis of teaching you the methods here and because I am too lazy to code it up as it is a faff, we will just remove them from the data. We ought to re-run our regression model since we are dropping two observations, but we will not to save time here (we will correct this later so stay tuned). Let’s check the spatial clustering in our outcome variable through calculating the Moran’s I. library(spdep) # Load package lad_eng &lt;- lad_eng[lad_eng$lad19cd != &quot;E06000053&quot; &amp; lad_eng$lad19cd != &quot;E06000046&quot;,] # Drop Isles of Scilly or Isle of Wight nb &lt;- poly2nb(lad_eng, queen = TRUE) # Calculate queen contiguity for areas (slow) lw &lt;- nb2listw(nb, style = &quot;W&quot;, zero.policy = TRUE) # Assign weights based on list of neighbours m1 &lt;- moran.test(lad_eng$percent_first_dose, lw) # Calculate Moran&#39;s I m1 # Print result ## ## Moran I test under randomisation ## ## data: lad_eng$percent_first_dose ## weights: lw ## ## Moran I statistic standard deviate = 11.055, p-value &lt; 2.2e-16 ## alternative hypothesis: greater ## sample estimates: ## Moran I statistic Expectation Variance ## 0.407962351 -0.003184713 0.001383250 A Moran’s I value of 0.4079624 would indicate existence of moderate spatial clustering of first COVID-19 vaccination dose uptake. Next, we will repeat the analysis for the regression model residuals. Remember this is more important in checking the model assumptions. m2 &lt;- moran.test(lad_eng$model1.residuals, lw) # Calculate Moran&#39;s I m2 # Print result ## ## Moran I test under randomisation ## ## data: lad_eng$model1.residuals ## weights: lw ## ## Moran I statistic standard deviate = 7.4067, p-value = 6.476e-14 ## alternative hypothesis: greater ## sample estimates: ## Moran I statistic Expectation Variance ## 0.271550385 -0.003184713 0.001375889 Here, a value of 0.2715504 suggests weak clustering. While low, the result is statistically significant suggesting it is important variation that we need to take in account in how we approach our regression analysis. Do you think that was a bit of a faff to code up? Well, you can do the whole thing in a single line of code thanks to spdep’s lm.morantest command. Indeed, it can allow us to update our regression model with the dropped observations quickly too. OK I should I have said this earlier to not waste your time, but sorry not sorry as it is useful to show the manual process I hope. model1 &lt;- lm(percent_first_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + pop_density, data = lad_eng) # Re-run regression model m3 &lt;- lm.morantest(model1, lw) # Run Moran&#39;s I analysis of residuals m3 # Print results ## ## Global Moran I for regression residuals ## ## data: ## model: lm(formula = percent_first_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + ## pop_density, data = lad_eng) ## weights: lw ## ## Moran I statistic standard deviate = 7.6783, p-value = 8.061e-15 ## alternative hypothesis: greater ## sample estimates: ## Observed Moran I Expectation Variance ## 0.271337873 -0.010969132 0.001351802 Again we get a similar result. So we have a problem. How might we address it? It might be that we have left out some unmeasured explanatory covariates that would account for the spatial variation. This might not always be possible. A different approach would be to account for the spatial structure of our underlying dataset. We could do this by adding in a categorical variable representing each area as a fixed effect in the regression model. You can try this by re-running the previous code and adding into the formula lad19cd - what are the issues this brings? We could also extend this model to be a multi-level regression model where the area identifier is specified as a random effect (check out R package lme4 for more here). Neither of these models explicitly accounts for the spatial nature of the data (i.e., the regression model does not know the spatial structure of the data). The other thing we could do is use a spatial regression model that explicitly accounts for the locations of each data point. Here we tell the regression model that the spatial structure of data points matters for their interpretation (i.e., data points closer to each other are more similar than those further apart). There are a lot of different types of spatial regression models. How might we select the correct model? Selection of models may be based on which specification we think best describes our data. This is hard to decide! The other approach is that we can utilise model fit statistics to assess which spatial models may improve upon the OLS regression model we previously fit. We can do this using spdep’s lm.LMtests function. Here we test for different features of spatial dependence in our data/model. For review here, please consult the lecture slides for this practical located here. Tl;dr spatial dependence is where the spatial configuration (i.e., structure of locations) affects our outcome. We will focus in this practical on spatial lag and spatial error models. The following code tests for whether a spatially lagged dependent variable or spatial error dependence can improve our model fit. We can test for more things using this code, but for now we stick with these four tests. spat_dep_test &lt;- lm.LMtests(model1, lw, test=c(&quot;LMerr&quot;, &quot;LMlag&quot;, &quot;RLMerr&quot;, &quot;RLMlag&quot;)) # Test for spatial dependence spat_dep_test ## ## Lagrange multiplier diagnostics for spatial dependence ## ## data: ## model: lm(formula = percent_first_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + ## pop_density, data = lad_eng) ## weights: lw ## ## LMerr = 52.31, df = 1, p-value = 4.738e-13 ## ## ## Lagrange multiplier diagnostics for spatial dependence ## ## data: ## model: lm(formula = percent_first_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + ## pop_density, data = lad_eng) ## weights: lw ## ## LMlag = 37.432, df = 1, p-value = 9.466e-10 ## ## ## Lagrange multiplier diagnostics for spatial dependence ## ## data: ## model: lm(formula = percent_first_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + ## pop_density, data = lad_eng) ## weights: lw ## ## RLMerr = 24.317, df = 1, p-value = 8.171e-07 ## ## ## Lagrange multiplier diagnostics for spatial dependence ## ## data: ## model: lm(formula = percent_first_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + ## pop_density, data = lad_eng) ## weights: lw ## ## RLMlag = 9.4386, df = 1, p-value = 0.002125 If we consider all of the tests, we can see that for each test of spatial dependence that they are each statistically significant. This would suggest that each spatial model can benefit our analysis and model fit. If none were significant, then we would use the OLS regression results. 3.4 Spatial lag model The first types of spatial models we will consider are those which incorporate a spatial lag. These models use variables that are spatially lagged, which means that they calculate measures for each area that characterise (e.g., mean value) their surrounding neighbours. Spatial lags might correspond to the outcome variable or explanatory variables. A spatial lag suggests that the surrounding areas have an influence on the outcome of an area. 3.4.1 SLX spatially lagged model The first spatial regression model we will consider is the SLX spatial lag model. SLX here means Spatially Lagged X-variables. We define the model as: \\[ y = X \\beta + WX \\theta + \\epsilon \\] The equation is a simple extension of the OLS regression equation. Our outcome variable \\(y\\) is a function of our explanatory variables \\(X\\) and their \\(\\beta\\) coefficients, a spatial lag coefficient \\(\\theta\\) of the \\(X\\) variables based on a spatial weight \\(W\\) and the error term \\(\\epsilon\\). The \\(\\beta\\) value represents the direct effect of an explanatory variable and the \\(\\theta\\) value represents the indirect effect. An indirect effect is synonymous with a spillover effect whereby changes in \\(x\\) in an area have on it’s surrounding neighbours based on how \\(W\\) is defined. The spatial lags are exogenous in definition. To fit the model, we use the R package spatialreg which allows us to fit cross-sectional spatial regression models. We re-run the previous analysis of first dose uptake using this spatial model and tidy the output (please note that gtsummary does not handle spatial models well). library(spatialreg) # Load package model2 &lt;- lmSLX(percent_first_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + pop_density, data = lad_eng, lw) # Spatial lag model tbl_model2 &lt;- tbl_regression(model2, label = list(median_age ~ &quot;Median age&quot;, Other_White ~ &quot;Other White (%)&quot;, Mixed ~ &quot;Mixed (%)&quot;, Black ~ &quot;Black (%)&quot;, Asian ~ &quot;Asian (%)&quot;, Other ~ &quot;Other Ethnicity (%)&quot;, mean_imd_score ~ &quot;Deprivation score&quot;, pop_density ~ &quot;Population density&quot;, lag.median_age ~ &quot;Lag: Median age&quot;, lag.Other_White ~ &quot;Lag: Other White (%)&quot;, lag.Mixed ~ &quot;Lag: Mixed (%)&quot;, lag.Black ~ &quot;Lag: Black (%)&quot;, lag.Asian ~ &quot;Lag: Asian (%)&quot;, lag.Other ~ &quot;Lag: Other Ethnicity (%)&quot;, lag.mean_imd_score ~ &quot;Lag: Deprivation score&quot;, lag.pop_density ~ &quot;Lag: Population density&quot;)) # Tidy model output tbl_model2 # Print html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #spertspcry .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #spertspcry .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #spertspcry .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #spertspcry .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #spertspcry .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #spertspcry .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #spertspcry .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #spertspcry .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #spertspcry .gt_column_spanner_outer:first-child { padding-left: 0; } #spertspcry .gt_column_spanner_outer:last-child { padding-right: 0; } #spertspcry .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #spertspcry .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #spertspcry .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #spertspcry .gt_from_md > :first-child { margin-top: 0; } #spertspcry .gt_from_md > :last-child { margin-bottom: 0; } #spertspcry .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #spertspcry .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #spertspcry .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #spertspcry .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #spertspcry .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #spertspcry .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #spertspcry .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #spertspcry .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #spertspcry .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #spertspcry .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #spertspcry .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #spertspcry .gt_sourcenote { font-size: 90%; padding: 4px; } #spertspcry .gt_left { text-align: left; } #spertspcry .gt_center { text-align: center; } #spertspcry .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #spertspcry .gt_font_normal { font-weight: normal; } #spertspcry .gt_font_bold { font-weight: bold; } #spertspcry .gt_font_italic { font-style: italic; } #spertspcry .gt_super { font-size: 65%; } #spertspcry .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Characteristic Beta 95% CI1 p-value Median age 0.90 0.81, 1.0 Other White (%) -0.08 -0.19, 0.03 0.2 Mixed (%) 0.31 -0.01, 0.62 0.055 Black (%) -0.17 -0.29, -0.06 0.003 Asian (%) 0.02 -0.03, 0.07 0.4 Other Ethnicity (%) -0.01 -0.24, 0.23 >0.9 Deprivation score -0.10 -0.15, -0.04 Population density 0.00 0.00, 0.00 0.4 Lag: Median age -0.07 -0.22, 0.09 0.4 Lag: Other White (%) 0.04 -0.16, 0.23 0.7 Lag: Mixed (%) 0.48 -0.14, 1.1 0.13 Lag: Black (%) -0.22 -0.45, 0.00 0.052 Lag: Asian (%) 0.04 -0.06, 0.13 0.4 Lag: Other Ethnicity (%) -0.19 -0.68, 0.29 0.4 Lag: Deprivation score -0.01 -0.09, 0.06 0.7 Lag: Population density 0.00 0.00, 0.00 0.046 1 CI = Confidence Interval To interpret the model can be difficult. The \\(\\beta\\) coefficients are not exactly the same. Rather, to understand the marginal effect of our covariates, we need to estimate their total impacts (i.e., direct effect + indirect effect). To do this, we use the following piece of code. model2_imp &lt;- impacts(model2, listw = lw) # Estimate direct, indirect and total effects of variables model2_imp # Print ## Impact measures (SLX, estimable): ## Direct Indirect Total ## median_age 0.9009090557 -0.0696177362 0.8312913196 ## Other_White -0.0790245349 0.0358434195 -0.0431811154 ## Mixed 0.3057806432 0.4837927431 0.7895733864 ## Black -0.1732816347 -0.2225162881 -0.3957979227 ## Asian 0.0188294285 0.0374534457 0.0562828742 ## Other -0.0058036010 -0.1928748969 -0.1986784979 ## mean_imd_score -0.0971854562 -0.0125373425 -0.1097227986 ## pop_density 0.0001022996 -0.0004974955 -0.0003951959 You will see here these are exactly the same as \\(\\beta\\) coefficients for this model, however this will not always be the case. What is useful here is that we can see the direct impact in an area, the indirect effects surrounding each and the total effect of each factor considering both together. The spatial lags here are mostly non-statistically significant, other than for population density. It suggests that they bring little to the model. Standard errors and p-values for these statistics can be estimated through the following modified version of the code. model2_imp_se &lt;- summary(impacts(model2, lw), zstats = TRUE) # Estimate model2_imp_se # Print ## Impact measures (SLX, estimable, n-k): ## Direct Indirect Total ## median_age 0.9009090557 -0.0696177362 0.8312913196 ## Other_White -0.0790245349 0.0358434195 -0.0431811154 ## Mixed 0.3057806432 0.4837927431 0.7895733864 ## Black -0.1732816347 -0.2225162881 -0.3957979227 ## Asian 0.0188294285 0.0374534457 0.0562828742 ## Other -0.0058036010 -0.1928748969 -0.1986784979 ## mean_imd_score -0.0971854562 -0.0125373425 -0.1097227986 ## pop_density 0.0001022996 -0.0004974955 -0.0003951959 ## ======================================================== ## Standard errors: ## Direct Indirect Total ## median_age 0.0479267084 0.0788605699 0.0759959852 ## Other_White 0.0554022011 0.1005400225 0.0903636892 ## Mixed 0.1589370191 0.3165363389 0.3306975306 ## Black 0.0588396940 0.1139981394 0.1050719658 ## Asian 0.0236130613 0.0476175809 0.0435460352 ## Other 0.1174828586 0.2470964358 0.2521944956 ## mean_imd_score 0.0268712927 0.0388509279 0.0305507387 ## pop_density 0.0001209284 0.0002482232 0.0002218059 ## ======================================================== ## Z-values: ## Direct Indirect Total ## median_age 18.79764092 -0.8827952 10.9386215 ## Other_White -1.42637898 0.3565090 -0.4778591 ## Mixed 1.92391077 1.5283956 2.3875999 ## Black -2.94497851 -1.9519291 -3.7669222 ## Asian 0.79741581 0.7865466 1.2924914 ## Other -0.04939956 -0.7805653 -0.7877987 ## mean_imd_score -3.61670192 -0.3227038 -3.5914941 ## pop_density 0.84595204 -2.0042263 -1.7817198 ## ## p-values: ## Direct Indirect Total ## median_age &lt; 2.22e-16 0.377347 &lt; 2.22e-16 ## Other_White 0.15375898 0.721459 0.63275046 ## Mixed 0.05436577 0.126414 0.01695879 ## Black 0.00322977 0.050947 0.00016527 ## Asian 0.42520958 0.431547 0.19618704 ## Other 0.96060088 0.435058 0.43081446 ## mean_imd_score 0.00029838 0.746920 0.00032879 ## pop_density 0.39757950 0.045046 0.07479493 We can also compare the results from the spatial model to our original OLS regression model tbl_merge(list(tbl_model1, tbl_model2)) # Combine both model outputs together html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #wbrozugdew .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #wbrozugdew .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #wbrozugdew .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #wbrozugdew .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #wbrozugdew .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #wbrozugdew .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #wbrozugdew .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #wbrozugdew .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #wbrozugdew .gt_column_spanner_outer:first-child { padding-left: 0; } #wbrozugdew .gt_column_spanner_outer:last-child { padding-right: 0; } #wbrozugdew .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #wbrozugdew .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #wbrozugdew .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #wbrozugdew .gt_from_md > :first-child { margin-top: 0; } #wbrozugdew .gt_from_md > :last-child { margin-bottom: 0; } #wbrozugdew .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #wbrozugdew .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #wbrozugdew .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #wbrozugdew .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #wbrozugdew .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #wbrozugdew .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #wbrozugdew .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #wbrozugdew .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #wbrozugdew .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #wbrozugdew .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #wbrozugdew .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #wbrozugdew .gt_sourcenote { font-size: 90%; padding: 4px; } #wbrozugdew .gt_left { text-align: left; } #wbrozugdew .gt_center { text-align: center; } #wbrozugdew .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #wbrozugdew .gt_font_normal { font-weight: normal; } #wbrozugdew .gt_font_bold { font-weight: bold; } #wbrozugdew .gt_font_italic { font-style: italic; } #wbrozugdew .gt_super { font-size: 65%; } #wbrozugdew .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Characteristic Table 1 Table 2 Beta 95% CI1 p-value Beta 95% CI1 p-value Median age 0.81 0.73, 0.90 0.90 0.81, 1.0 Other White (%) -0.07 -0.16, 0.02 0.11 -0.08 -0.19, 0.03 0.2 Mixed (%) 0.40 0.09, 0.71 0.012 0.31 -0.01, 0.62 0.055 Black (%) -0.25 -0.35, -0.15 -0.17 -0.29, -0.06 0.003 Asian (%) 0.02 -0.02, 0.06 0.4 0.02 -0.03, 0.07 0.4 Other Ethnicity (%) -0.14 -0.36, 0.08 0.2 -0.01 -0.24, 0.23 >0.9 Deprivation score -0.10 -0.14, -0.06 -0.10 -0.15, -0.04 Population density 0.00 0.00, 0.00 0.015 0.00 0.00, 0.00 0.4 Lag: Median age -0.07 -0.22, 0.09 0.4 Lag: Other White (%) 0.04 -0.16, 0.23 0.7 Lag: Mixed (%) 0.48 -0.14, 1.1 0.13 Lag: Black (%) -0.22 -0.45, 0.00 0.052 Lag: Asian (%) 0.04 -0.06, 0.13 0.4 Lag: Other Ethnicity (%) -0.19 -0.68, 0.29 0.4 Lag: Deprivation score -0.01 -0.09, 0.06 0.7 Lag: Population density 0.00 0.00, 0.00 0.046 1 CI = Confidence Interval Not a lot has changed if we compare the direct effects of coefficients (many remain within their 95% confidence intervals), probably because the spatial lagged effects were not strong or identifiable. Population density has become non-statistically significant mind you, as has percentage of people who with mixed ethnicity. We can also compare model fit to see if the spatial model improves on the original OLS regression model. For example, we can check this by quickly looking at the AIC model fit. AIC(model1) # OLS regression model ## [1] 1424.31 AIC(model2) # SLX spatial lag model ## [1] 1406.79 The spatial lag model does improve model fit overall. 3.4.2 SAR Spatial Lag The other spatial lag model that we can specify is the following: \\[ y = \\rho Wy + X\\beta + \\epsilon \\] SAR stands for Spatial AutoRegressive model. Here, we have the standard OLS regression equation \\(X\\beta + \\epsilon\\), however we also have included a spatial lag component \\(\\rho W\\) of our outcome variable \\(y\\). \\(W\\) is once again our spatial weights matrix, with \\(\\rho\\) representing the correlation of the spatial lag of \\(y\\) to \\(y\\). Since the model contains \\(y\\) at both sides of the equation, it violates the exogeneity assumption of the OLS regression model. We therefore need a different approach to estimate the equation. Please note: gtsummary does not handle spatial models well, so we will have to fudge it persist a bit here. If you can fix it, send your answers on a postcard/carrier pigeon please. Remember, you can always get the raw output of a model by using summary(model3). model3 &lt;- lagsarlm(percent_first_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + pop_density, data = lad_eng, lw) # Model tbl_model3 &lt;- tbl_regression(model3) # Tidy model output tbl_model3 # Print html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #uxoietalfs .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #uxoietalfs .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #uxoietalfs .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #uxoietalfs .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #uxoietalfs .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #uxoietalfs .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #uxoietalfs .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #uxoietalfs .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #uxoietalfs .gt_column_spanner_outer:first-child { padding-left: 0; } #uxoietalfs .gt_column_spanner_outer:last-child { padding-right: 0; } #uxoietalfs .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #uxoietalfs .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #uxoietalfs .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #uxoietalfs .gt_from_md > :first-child { margin-top: 0; } #uxoietalfs .gt_from_md > :last-child { margin-bottom: 0; } #uxoietalfs .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #uxoietalfs .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #uxoietalfs .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #uxoietalfs .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #uxoietalfs .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #uxoietalfs .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #uxoietalfs .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #uxoietalfs .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #uxoietalfs .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #uxoietalfs .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #uxoietalfs .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #uxoietalfs .gt_sourcenote { font-size: 90%; padding: 4px; } #uxoietalfs .gt_left { text-align: left; } #uxoietalfs .gt_center { text-align: center; } #uxoietalfs .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #uxoietalfs .gt_font_normal { font-weight: normal; } #uxoietalfs .gt_font_bold { font-weight: bold; } #uxoietalfs .gt_font_italic { font-style: italic; } #uxoietalfs .gt_super { font-size: 65%; } #uxoietalfs .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Characteristic Beta 95% CI1 p-value rho 0.23 0.16, 0.29 (Intercept) 16 10, 22 median_age 0.84 0.76, 0.92 Other_White -0.09 -0.17, -0.01 0.029 Mixed 0.39 0.10, 0.68 0.008 Black -0.17 -0.26, -0.07 Asian 0.04 0.00, 0.08 0.044 Other -0.04 -0.24, 0.16 0.7 mean_imd_score -0.11 -0.15, -0.08 pop_density 0.00 0.00, 0.00 0.15 1 CI = Confidence Interval Let’s compare it to our standard OLS regression model. We will go back to the untidy version of the output to match the above tbl_model1 &lt;- tbl_regression(model1, intercept = TRUE) # Redo Table 1 to match above format tbl_merge(tbls = list(tbl_model1, tbl_model3), # Join output together tab_spanner = c(&quot;**OLS**&quot;, &quot;**Spatial Lag**&quot;)) # Rename columns (in bold) ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #oewslwquxi .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #oewslwquxi .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #oewslwquxi .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #oewslwquxi .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #oewslwquxi .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #oewslwquxi .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #oewslwquxi .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #oewslwquxi .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #oewslwquxi .gt_column_spanner_outer:first-child { padding-left: 0; } #oewslwquxi .gt_column_spanner_outer:last-child { padding-right: 0; } #oewslwquxi .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #oewslwquxi .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #oewslwquxi .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #oewslwquxi .gt_from_md > :first-child { margin-top: 0; } #oewslwquxi .gt_from_md > :last-child { margin-bottom: 0; } #oewslwquxi .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #oewslwquxi .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #oewslwquxi .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #oewslwquxi .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #oewslwquxi .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #oewslwquxi .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #oewslwquxi .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #oewslwquxi .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #oewslwquxi .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #oewslwquxi .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #oewslwquxi .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #oewslwquxi .gt_sourcenote { font-size: 90%; padding: 4px; } #oewslwquxi .gt_left { text-align: left; } #oewslwquxi .gt_center { text-align: center; } #oewslwquxi .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #oewslwquxi .gt_font_normal { font-weight: normal; } #oewslwquxi .gt_font_bold { font-weight: bold; } #oewslwquxi .gt_font_italic { font-style: italic; } #oewslwquxi .gt_super { font-size: 65%; } #oewslwquxi .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Characteristic OLS Spatial Lag Beta 95% CI1 p-value Beta 95% CI1 p-value (Intercept) 32 28, 36 16 10, 22 median_age 0.81 0.73, 0.90 0.84 0.76, 0.92 Other_White -0.07 -0.16, 0.02 0.13 -0.09 -0.17, -0.01 0.029 Mixed 0.42 0.10, 0.73 0.009 0.39 0.10, 0.68 0.008 Black -0.25 -0.36, -0.15 -0.17 -0.26, -0.07 Asian 0.02 -0.02, 0.06 0.4 0.04 0.00, 0.08 0.044 Other -0.14 -0.36, 0.07 0.2 -0.04 -0.24, 0.16 0.7 mean_imd_score -0.10 -0.14, -0.06 -0.11 -0.15, -0.08 pop_density 0.00 0.00, 0.00 0.013 0.00 0.00, 0.00 0.15 rho 0.23 0.16, 0.29 1 CI = Confidence Interval Not a lot has changed between the models, suggesting that the spatial patterns captured very little of the patterns observed in our covariates. The most interesting difference is for our population density variable pop_density, which has gone from statistically significant in our OLS regression model to insignificant in our spatial lag model. The percentage of people with their ethnicity as other White (Other_White) has now become statistically significant as well, with a negative association to the percentage vaccinated. Otherwise, the coefficients have remained similar and within the 95% Confidence Intervals of the OLS estimates. The summary output for the spatial lag model gives us only the direct impacts for our coefficients, however we may be interested in the direct, indirect and total effects each covariate is having on our outcome variable. impacts(model3, listw = lw) # Estimate direct and indirect effects ## Impact measures (lag, exact): ## Direct Indirect Total ## median_age 0.8509693217 2.364693e-01 1.0874386629 ## Other_White -0.0930566879 -2.585881e-02 -0.1189154975 ## Mixed 0.3929949698 1.092064e-01 0.5022013292 ## Black -0.1678335124 -4.663797e-02 -0.2144714806 ## Asian 0.0406973608 1.130908e-02 0.0520064384 ## Other -0.0389923533 -1.083529e-02 -0.0498276394 ## mean_imd_score -0.1152847834 -3.203560e-02 -0.1473203881 ## pop_density -0.0001353991 -3.762503e-05 -0.0001730242 The table would suggest that the indirect effects of each covariate on the surrounding areas means that focusing on the direct association alone underestimates the total impact of each variable. To get the standard errors and p-values for our direct, indirect and total effects, we use the following code. Unlike the SLX model, we cannot estimate these directly and therefore must use simulations (MCMC) approaches to estimate them. This only requires a slight modification to the code, in our case we will add in 500 simulations (the more the merrier, but impacts on processing time). summary(impacts(model3, listw = lw, R = 500), zstats = TRUE) # Slow, but gives quantiles etc ## Impact measures (lag, exact): ## Direct Indirect Total ## median_age 0.8509693217 2.364693e-01 1.0874386629 ## Other_White -0.0930566879 -2.585881e-02 -0.1189154975 ## Mixed 0.3929949698 1.092064e-01 0.5022013292 ## Black -0.1678335124 -4.663797e-02 -0.2144714806 ## Asian 0.0406973608 1.130908e-02 0.0520064384 ## Other -0.0389923533 -1.083529e-02 -0.0498276394 ## mean_imd_score -0.1152847834 -3.203560e-02 -0.1473203881 ## pop_density -0.0001353991 -3.762503e-05 -0.0001730242 ## ======================================================== ## Simulation results (asymptotic variance matrix): ## Direct: ## ## Iterations = 1:500 ## Thinning interval = 1 ## Number of chains = 1 ## Sample size per chain = 500 ## ## 1. Empirical mean and standard deviation for each variable, ## plus standard error of the mean: ## ## Mean SD Naive SE Time-series SE ## median_age 0.8525121 4.038e-02 1.806e-03 1.806e-03 ## Other_White -0.0931258 4.419e-02 1.976e-03 1.976e-03 ## Mixed 0.3982622 1.494e-01 6.682e-03 6.682e-03 ## Black -0.1656767 5.150e-02 2.303e-03 2.157e-03 ## Asian 0.0403707 2.028e-02 9.068e-04 9.068e-04 ## Other -0.0346247 1.024e-01 4.580e-03 4.580e-03 ## mean_imd_score -0.1137616 1.920e-02 8.588e-04 8.588e-04 ## pop_density -0.0001375 9.734e-05 4.353e-06 4.353e-06 ## ## 2. Quantiles for each variable: ## ## 2.5% 25% 50% 75% 97.5% ## median_age 0.7742765 0.825442 0.8538912 8.782e-01 9.249e-01 ## Other_White -0.1786118 -0.121101 -0.0927149 -6.467e-02 -1.025e-02 ## Mixed 0.1137999 0.303110 0.4026023 4.936e-01 6.791e-01 ## Black -0.2702979 -0.200784 -0.1657098 -1.294e-01 -7.291e-02 ## Asian 0.0013119 0.025561 0.0400029 5.471e-02 7.826e-02 ## Other -0.2354788 -0.098935 -0.0333859 3.072e-02 1.562e-01 ## mean_imd_score -0.1501918 -0.126077 -0.1143237 -1.021e-01 -7.450e-02 ## pop_density -0.0003154 -0.000204 -0.0001362 -7.563e-05 5.295e-05 ## ## ======================================================== ## Indirect: ## ## Iterations = 1:500 ## Thinning interval = 1 ## Number of chains = 1 ## Sample size per chain = 500 ## ## 1. Empirical mean and standard deviation for each variable, ## plus standard error of the mean: ## ## Mean SD Naive SE Time-series SE ## median_age 2.405e-01 5.020e-02 2.245e-03 2.245e-03 ## Other_White -2.644e-02 1.424e-02 6.370e-04 5.752e-04 ## Mixed 1.129e-01 4.999e-02 2.235e-03 2.235e-03 ## Black -4.619e-02 1.592e-02 7.122e-04 7.122e-04 ## Asian 1.156e-02 6.640e-03 2.969e-04 2.969e-04 ## Other -9.145e-03 2.925e-02 1.308e-03 1.308e-03 ## mean_imd_score -3.218e-02 8.807e-03 3.939e-04 3.591e-04 ## pop_density -3.786e-05 2.731e-05 1.221e-06 1.221e-06 ## ## 2. Quantiles for each variable: ## ## 2.5% 25% 50% 75% 97.5% ## median_age 1.536e-01 2.041e-01 2.366e-01 2.754e-01 3.402e-01 ## Other_White -5.527e-02 -3.480e-02 -2.552e-02 -1.696e-02 -2.372e-03 ## Mixed 2.852e-02 7.892e-02 1.091e-01 1.447e-01 2.175e-01 ## Black -7.968e-02 -5.651e-02 -4.486e-02 -3.477e-02 -1.970e-02 ## Asian 3.712e-04 6.883e-03 1.076e-02 1.592e-02 2.528e-02 ## Other -7.010e-02 -2.694e-02 -9.219e-03 8.430e-03 4.732e-02 ## mean_imd_score -5.121e-02 -3.791e-02 -3.172e-02 -2.601e-02 -1.645e-02 ## pop_density -9.482e-05 -5.543e-05 -3.776e-05 -2.012e-05 1.481e-05 ## ## ======================================================== ## Total: ## ## Iterations = 1:500 ## Thinning interval = 1 ## Number of chains = 1 ## Sample size per chain = 500 ## ## 1. Empirical mean and standard deviation for each variable, ## plus standard error of the mean: ## ## Mean SD Naive SE Time-series SE ## median_age 1.0929770 0.0736553 3.294e-03 3.294e-03 ## Other_White -0.1195685 0.0574824 2.571e-03 2.571e-03 ## Mixed 0.5111369 0.1947910 8.711e-03 8.711e-03 ## Black -0.2118644 0.0650089 2.907e-03 2.907e-03 ## Asian 0.0519308 0.0264846 1.184e-03 1.184e-03 ## Other -0.0437694 0.1311488 5.865e-03 5.865e-03 ## mean_imd_score -0.1459417 0.0260142 1.163e-03 1.163e-03 ## pop_density -0.0001753 0.0001234 5.517e-06 5.517e-06 ## ## 2. Quantiles for each variable: ## ## 2.5% 25% 50% 75% 97.5% ## median_age 0.9555211 1.0432652 1.0900711 1.146e+00 1.236e+00 ## Other_White -0.2328298 -0.1560703 -0.1194452 -8.298e-02 -1.277e-02 ## Mixed 0.1390956 0.3846310 0.5179249 6.328e-01 8.995e-01 ## Black -0.3357829 -0.2559570 -0.2117105 -1.670e-01 -9.434e-02 ## Asian 0.0016831 0.0328099 0.0516210 7.085e-02 1.019e-01 ## Other -0.3009490 -0.1265225 -0.0430737 4.023e-02 1.966e-01 ## mean_imd_score -0.1950171 -0.1623149 -0.1468028 -1.305e-01 -9.528e-02 ## pop_density -0.0003987 -0.0002676 -0.0001727 -9.592e-05 6.967e-05 ## ## ======================================================== ## Simulated standard errors ## Direct Indirect Total ## median_age 4.038093e-02 5.020011e-02 0.0736552558 ## Other_White 4.419156e-02 1.424436e-02 0.0574823745 ## Mixed 1.494219e-01 4.998651e-02 0.1947909898 ## Black 5.149804e-02 1.592425e-02 0.0650089053 ## Asian 2.027763e-02 6.639541e-03 0.0264846444 ## Other 1.024182e-01 2.925324e-02 0.1311488321 ## mean_imd_score 1.920265e-02 8.807172e-03 0.0260142304 ## pop_density 9.734392e-05 2.730753e-05 0.0001233592 ## ## Simulated z-values: ## Direct Indirect Total ## median_age 21.1117524 4.7901252 14.839090 ## Other_White -2.1073216 -1.8563599 -2.080090 ## Mixed 2.6653536 2.2581031 2.624027 ## Black -3.2171469 -2.9004602 -3.259006 ## Asian 1.9908999 1.7410899 1.960788 ## Other -0.3380712 -0.3126044 -0.333738 ## mean_imd_score -5.9242663 -3.6538507 -5.610072 ## pop_density -1.4122687 -1.3864974 -1.421358 ## ## Simulated p-values: ## Direct Indirect Total ## median_age &lt; 2.22e-16 1.6668e-06 &lt; 2.22e-16 ## Other_White 0.0350897 0.06340228 0.0375173 ## Mixed 0.0076907 0.02393924 0.0086897 ## Black 0.0012947 0.00372615 0.0011180 ## Asian 0.0464919 0.08166783 0.0499038 ## Other 0.7353095 0.75458121 0.7385772 ## mean_imd_score 3.1369e-09 0.00025834 2.0224e-08 ## pop_density 0.1578709 0.16559506 0.1552128 It gives a lot of output, but it is useful to pick apart how useful our estimates are. 3.5 Spatial error models We next explore how to implement spatial error models. The underlying models are modified OLS regression models meaning the models are more straightforward ways of accounting for spatial processes in our analysis, as well as being fairly easy to interpret. In this section, we will deal with models that incorporate the spatial structure of the dataset within the error terms. Remember that this was the key OLS assumption that might have been violated (i.e., independence of errors). 3.5.1 Spatial Error Model (SEM) The main equation that we are trying to estimate in our spatial error model is: \\[ y = X\\beta + u \\] Here, we are trying to explain our outcome variable \\(y\\) based upon our the \\(\\beta\\) coefficients of covariate variables \\(X\\) plus our error term \\(u\\). The equation itself looks fairly similar to the OLS equation, until we introduce the spatial autocorrelation element to our model. We partition \\(u\\) into the following: \\[ u = \\lambda Wu + \\epsilon \\] We define \\(u\\) as a coefficient \\(\\lambda\\) controlling the spatial weight \\(W\\) placed on the the error terms \\(u\\), plus the general error term \\(\\epsilon\\) for our model. We cannot use the OLS regression model to estimate the equation, since the assumption of independence of error terms is violated. We therefore require new approaches to do this. Again, gtsummary doesn’t like these types of models but I have included here as it helps clean the output up. model4 &lt;- errorsarlm(percent_first_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + pop_density, data = lad_eng, lw) # Model tbl_model4 &lt;- tbl_regression(model4) # Tidy model output ## x Unable to identify the list of variables. ## ## This is usually due to an error calling `stats::model.frame(x)`or `stats::model.matrix(x)`. ## It could be the case if that type of model does not implement these methods. ## Rarely, this error may occur if the model object was created within ## a functional programming framework (e.g. using `lappy()`, `purrr::map()`, etc.). tbl_model4 # Print ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead ## Warning: `columns = vars(...)` has been deprecated in gt 0.3.0: ## * please use `columns = c(...)` instead html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #sbgjgzhvtc .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #sbgjgzhvtc .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #sbgjgzhvtc .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #sbgjgzhvtc .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #sbgjgzhvtc .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #sbgjgzhvtc .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #sbgjgzhvtc .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #sbgjgzhvtc .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #sbgjgzhvtc .gt_column_spanner_outer:first-child { padding-left: 0; } #sbgjgzhvtc .gt_column_spanner_outer:last-child { padding-right: 0; } #sbgjgzhvtc .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #sbgjgzhvtc .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #sbgjgzhvtc .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #sbgjgzhvtc .gt_from_md > :first-child { margin-top: 0; } #sbgjgzhvtc .gt_from_md > :last-child { margin-bottom: 0; } #sbgjgzhvtc .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #sbgjgzhvtc .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #sbgjgzhvtc .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #sbgjgzhvtc .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #sbgjgzhvtc .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #sbgjgzhvtc .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #sbgjgzhvtc .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #sbgjgzhvtc .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #sbgjgzhvtc .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #sbgjgzhvtc .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #sbgjgzhvtc .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #sbgjgzhvtc .gt_sourcenote { font-size: 90%; padding: 4px; } #sbgjgzhvtc .gt_left { text-align: left; } #sbgjgzhvtc .gt_center { text-align: center; } #sbgjgzhvtc .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #sbgjgzhvtc .gt_font_normal { font-weight: normal; } #sbgjgzhvtc .gt_font_bold { font-weight: bold; } #sbgjgzhvtc .gt_font_italic { font-style: italic; } #sbgjgzhvtc .gt_super { font-size: 65%; } #sbgjgzhvtc .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Characteristic Beta 95% CI1 p-value (Intercept) 29 25, 33 median_age 0.87 0.79, 0.95 Other_White -0.11 -0.19, -0.02 0.020 Mixed 0.24 -0.03, 0.51 0.078 Black -0.19 -0.28, -0.09 Asian 0.01 -0.03, 0.05 0.5 Other 0.00 -0.20, 0.19 >0.9 mean_imd_score -0.08 -0.12, -0.04 pop_density 0.00 0.00, 0.00 0.6 lambda 0.62 0.51, 0.72 1 CI = Confidence Interval These models do not have direct and indirect effects since the spatial component only affects the error term. We may also want to check whether a spatial error model was relevant here through running a Hausman Test which compares if the model improves upon the OLS model. HausmanTest &lt;- Hausman.test(model4) # Run test HausmanTest # Print ## ## Spatial Hausman test (asymptotic) ## ## data: NULL ## Hausman test = 21.562, df = 9, p-value = 0.01038 The test suggests that the spatial error improves the model (i.e., we want it to be statistically significant). We can compare the model output to the OLS and spatial lag models too. tbl_merge(tbls = list(tbl_model1, tbl_model3, tbl_model4), # Join three model outputs together tab_spanner = c(&quot;**OLS**&quot;, &quot;**Spatial Lag**&quot;, &quot;**Spatial Error**&quot;)) # Rename columns (in bold) html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #nymtpmrsvs .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #nymtpmrsvs .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #nymtpmrsvs .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #nymtpmrsvs .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #nymtpmrsvs .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #nymtpmrsvs .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #nymtpmrsvs .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #nymtpmrsvs .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #nymtpmrsvs .gt_column_spanner_outer:first-child { padding-left: 0; } #nymtpmrsvs .gt_column_spanner_outer:last-child { padding-right: 0; } #nymtpmrsvs .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #nymtpmrsvs .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #nymtpmrsvs .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #nymtpmrsvs .gt_from_md > :first-child { margin-top: 0; } #nymtpmrsvs .gt_from_md > :last-child { margin-bottom: 0; } #nymtpmrsvs .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #nymtpmrsvs .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #nymtpmrsvs .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #nymtpmrsvs .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #nymtpmrsvs .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #nymtpmrsvs .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #nymtpmrsvs .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #nymtpmrsvs .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #nymtpmrsvs .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #nymtpmrsvs .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #nymtpmrsvs .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #nymtpmrsvs .gt_sourcenote { font-size: 90%; padding: 4px; } #nymtpmrsvs .gt_left { text-align: left; } #nymtpmrsvs .gt_center { text-align: center; } #nymtpmrsvs .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #nymtpmrsvs .gt_font_normal { font-weight: normal; } #nymtpmrsvs .gt_font_bold { font-weight: bold; } #nymtpmrsvs .gt_font_italic { font-style: italic; } #nymtpmrsvs .gt_super { font-size: 65%; } #nymtpmrsvs .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Characteristic OLS Spatial Lag Spatial Error Beta 95% CI1 p-value Beta 95% CI1 p-value Beta 95% CI1 p-value (Intercept) 32 28, 36 16 10, 22 29 25, 33 median_age 0.81 0.73, 0.90 0.84 0.76, 0.92 0.87 0.79, 0.95 Other_White -0.07 -0.16, 0.02 0.13 -0.09 -0.17, -0.01 0.029 -0.11 -0.19, -0.02 0.020 Mixed 0.42 0.10, 0.73 0.009 0.39 0.10, 0.68 0.008 0.24 -0.03, 0.51 0.078 Black -0.25 -0.36, -0.15 -0.17 -0.26, -0.07 -0.19 -0.28, -0.09 Asian 0.02 -0.02, 0.06 0.4 0.04 0.00, 0.08 0.044 0.01 -0.03, 0.05 0.5 Other -0.14 -0.36, 0.07 0.2 -0.04 -0.24, 0.16 0.7 0.00 -0.20, 0.19 >0.9 mean_imd_score -0.10 -0.14, -0.06 -0.11 -0.15, -0.08 -0.08 -0.12, -0.04 pop_density 0.00 0.00, 0.00 0.013 0.00 0.00, 0.00 0.15 0.00 0.00, 0.00 0.6 rho 0.23 0.16, 0.29 lambda 0.62 0.51, 0.72 1 CI = Confidence Interval The spatial error model looks relatively similar to the spatial lag model, although there are some differences with Mixed and Asian variables now being statistically insignificant. 3.5.2 Spatial Durbin Error We can extend the spatial error model through adding in spatial lags for our x-variables, accounting for the spatial effects of independent variables. This requires only a minor modification of the spatial error model equation: \\[ y = X\\beta + WX\\theta + u \\] The key difference to the spatial error model is the introduction of \\(WX\\theta\\) which applies the spatial weight \\(W\\) to the independent variables \\(X\\) and our spatial autocorrelation coefficient \\(\\theta\\). \\(u\\) again is defined as: \\[ u = \\lambda Wu + \\epsilon \\] We can fit this model using a slight change to the spatial error code. Please note that gtsummary does not like this type of model output either, so it is a little messy again. model5 &lt;- errorsarlm(percent_first_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + pop_density, data = lad_eng, lw, etype = &quot;emixed&quot;) # Fit model tbl_model5 &lt;- tbl_regression(model5) # Tidy model output tbl_model5 # Print html { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', 'Fira Sans', 'Droid Sans', Arial, sans-serif; } #xrniunwets .gt_table { display: table; border-collapse: collapse; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #xrniunwets .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #xrniunwets .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #xrniunwets .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 0; padding-bottom: 4px; border-top-color: #FFFFFF; border-top-width: 0; } #xrniunwets .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xrniunwets .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #xrniunwets .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #xrniunwets .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #xrniunwets .gt_column_spanner_outer:first-child { padding-left: 0; } #xrniunwets .gt_column_spanner_outer:last-child { padding-right: 0; } #xrniunwets .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; overflow-x: hidden; display: inline-block; width: 100%; } #xrniunwets .gt_group_heading { padding: 8px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; } #xrniunwets .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #xrniunwets .gt_from_md > :first-child { margin-top: 0; } #xrniunwets .gt_from_md > :last-child { margin-bottom: 0; } #xrniunwets .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #xrniunwets .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 12px; } #xrniunwets .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #xrniunwets .gt_first_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; } #xrniunwets .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #xrniunwets .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #xrniunwets .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #xrniunwets .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #xrniunwets .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #xrniunwets .gt_footnote { margin: 0px; font-size: 90%; padding: 4px; } #xrniunwets .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #xrniunwets .gt_sourcenote { font-size: 90%; padding: 4px; } #xrniunwets .gt_left { text-align: left; } #xrniunwets .gt_center { text-align: center; } #xrniunwets .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #xrniunwets .gt_font_normal { font-weight: normal; } #xrniunwets .gt_font_bold { font-weight: bold; } #xrniunwets .gt_font_italic { font-style: italic; } #xrniunwets .gt_super { font-size: 65%; } #xrniunwets .gt_footnote_marks { font-style: italic; font-weight: normal; font-size: 65%; } Characteristic Beta 95% CI1 p-value (Intercept) 31 22, 41 median_age 0.91 0.83, 1.0 Other_White -0.10 -0.19, -0.01 0.034 Mixed 0.28 0.00, 0.57 0.049 Black -0.20 -0.30, -0.10 Asian 0.02 -0.02, 0.06 0.4 Other 0.00 -0.20, 0.21 >0.9 mean_imd_score -0.07 -0.11, -0.03 0.001 pop_density 0.00 0.00, 0.00 0.6 lag.median_age -0.08 -0.25, 0.08 0.3 lag.Other_White 0.08 -0.14, 0.29 0.5 lag.Mixed 0.62 -0.04, 1.3 0.064 lag.Black -0.11 -0.35, 0.14 0.4 lag.Asian 0.02 -0.08, 0.12 0.7 lag.Other -0.38 -0.93, 0.16 0.2 lag.mean_imd_score -0.06 -0.14, 0.02 0.14 lag.pop_density 0.00 0.00, 0.00 0.15 lambda 0.55 0.43, 0.66 1 CI = Confidence Interval The inclusion of spatial lags does not seem to bring much advantage here. Since we have introduced spatial lags into our model, we can also calculate the direct, indirect and total effects of covariates too. I have included the code for calculating standard errors, however we don’t need to run it again because I am lazy. impacts(model5, listw = lw) # Calculate indirect, direct and total effects ## Impact measures (SDEM, estimable): ## Direct Indirect Total ## median_age 9.115621e-01 -0.0841690665 0.8273930013 ## Other_White -9.924527e-02 0.0753496736 -0.0238955924 ## Mixed 2.834532e-01 0.6242855916 0.9077388144 ## Black -2.041149e-01 -0.1070505848 -0.3111654388 ## Asian 1.583933e-02 0.0209621790 0.0368015073 ## Other 3.784383e-03 -0.3849049537 -0.3811205710 ## mean_imd_score -7.049241e-02 -0.0594952812 -0.1299876895 ## pop_density 5.783698e-05 -0.0003724632 -0.0003146262 # summary(impacts(model3, listw = lw, R = 500), zstats = TRUE) # Slow, but gives quantiles, standard errors and p-values There are more extensions of these models than you can shake a stick at we could explore here - for example, SARAR or SARMA - and most of them are essentially different combinations of spatial lags and spatial error models. We can save them for a rainy day. 3.6 Summary In this practical session, we have explored how to extend the standard OLS regression model to incorporate spatial processes. We will continue this theme in the next, and final, session where we examine Geographically Weighted Regression. "],["gwr.html", "Chapter 4 Geographically Weighted Regression 4.1 Loading data 4.2 Selecting bandwidths 4.3 Running the model 4.4 Scaling GWR for large datasets 4.5 Summary", " Chapter 4 Geographically Weighted Regression In our last session (boo), we extend the spatial regression approach to explore the concept of spatially varying coefficients. The lecture slides for this practical can be found here: powerpoint or pdf. 4.1 Loading data We will use the same data introduced in the previous session. We will this time look at second dose uptake to mix it up. Let’s quickly load in the data and tidy it. # Load package library(sf) # Load and clean spatial data lad_uk &lt;- read_sf(&quot;./Shapefiles/UK_LAD/Local_Authority_Districts_(December_2019)_Boundaries_UK_BFC.shp&quot;) # Load shapefile for Local Authority Districts (LADs) for UK (sorry but could not find only England version so need to convert to match data) lad_uk$country &lt;- substr(lad_uk$lad19cd, 0, 1) # Record first letter of LAD code (denotes country) lad_eng &lt;- lad_uk[lad_uk$country == &quot;E&quot;,] # Subset only English LADs # Tidy and join on explanatory variables lad_data &lt;- read.csv(&quot;./Data/LAD_vaccine_data.csv&quot;) # Load vaccine uptake and demographic data for England lad_eng &lt;- merge(lad_eng, lad_data, by.x = &quot;lad19cd&quot;, by.y = &quot;ltla_code&quot;, all.x = TRUE) # Join on both datasets lad_eng$pop_density &lt;- lad_eng$population / (lad_eng$st_areasha / 1000000) # Calculate population density (st_areashape is measured in metres^2 so need to convert to km^2 by dividing by 1,000,000) lad_eng$percent_first_dose &lt;- (lad_eng$total_first_dose / lad_eng$population) * 100 # Calculate percent of population who have had their first dose lad_eng$percent_second_dose &lt;- (lad_eng$total_second_dose / lad_eng$population) * 100 # Calculate percent of population who have had their first dose # Remove objects to save space rm(lad_uk, lad_data) Let’s have a look at the spatial pattern of the variable. # Load packages library(ggplot2) library(viridis) # Plot map1 &lt;- ggplot() + # Call ggplot command geom_sf(data = lad_eng, aes(fill = percent_second_dose), lwd = 0) + # Define what to plot scale_fill_viridis() + # Make colourblind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Second dose uptake&quot;, # Edit plot title fill = &quot;Percent (%)&quot;) # Edit legend title map1 # Print plot We can see lower uptake in urban areas and higher uptake in rural regions. This is likely reflecting differences in the age-structure of areas. Let’s use a standard linear regression model to examine the factors that are associated with the percentage of individuals who are fully vaccinated (i.e., received their second vaccine dose). This will be useful to compare to the Geographically Weighted Regression (GWR) model later. model1 &lt;- lm(percent_second_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + pop_density, data = lad_eng) # OLS model summary(model1) # Print model results ## ## Call: ## lm(formula = percent_second_dose ~ median_age + Other_White + ## Mixed + Black + Asian + Other + mean_imd_score + pop_density, ## data = lad_eng) ## ## Residuals: ## Min 1Q Median 3Q Max ## -17.9897 -1.5236 -0.1079 1.4989 14.1068 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 4.7972830 2.4171174 1.985 0.048063 * ## median_age 1.0410090 0.0486634 21.392 &lt; 2e-16 *** ## Other_White -0.1070692 0.0520983 -2.055 0.040709 * ## Mixed 0.1228759 0.1817387 0.676 0.499476 ## Black -0.1811159 0.0587695 -3.082 0.002243 ** ## Asian -0.0259803 0.0244621 -1.062 0.289039 ## Other -0.1225451 0.1258458 -0.974 0.330934 ## mean_imd_score 0.0204583 0.0220153 0.929 0.353474 ## pop_density -0.0004277 0.0001139 -3.756 0.000206 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 2.616 on 308 degrees of freedom ## Multiple R-squared: 0.8804, Adjusted R-squared: 0.8773 ## F-statistic: 283.5 on 8 and 308 DF, p-value: &lt; 2.2e-16 The model results suggest the following associations: Median age of a Local Authority is positively associated with the percentage of the population who have had their second vaccine dose, so that older populations had more fully vaccinated individuals Greater percentages of areas with Black or Other White ethnic groups had lower uptake, with a negative association detected. Population density was negatively associated to vaccination uptake, with uptake decreasing with increasing population density. 4.2 Selecting bandwidths GWR is a technique that allows us to examine how associations between variables may vary across space. It works through selecting a ‘search window’ (here defined as surrounding areas) over each data point (Local Authority District in our example), estimating a regression equation (for the data point and data points in the search window, with closer neighbouring data points given larger weightings), and then repeating the process for all data points. This means the process estimates n regression equations each time (you can probably see here how it can become computationally intensive). The result is a series of regression coefficients for each variable and each area, allowing us to explore how coefficients vary across space. To be able to estimate a model, we need to define the ‘search window.’ This consists of two components: (i) a spatial kernel, and (ii) bandwidth. The spatial kernel refers to the weighting mechanism that gives greater importance/weighting to data points located closer to each data point (and vice versa), and the extent that the weighting changes with distance. The kernel can be fixed (i.e., the same bandwidth, such as a fixed distance, is used for each regression) or adaptive (i.e., varying bandwidths are used, such as nearest number of neighbours). Bandwidith is the extent of the kernel (i.e., how big an area it covers). We can optimise the bandwidth value using a cross-validation. Here we estimate a regression model for a particular location with a set bandwidth value. We then compare the predicted outcome value for the model to the observed/actual value, which gives us the residual error. We can then vary the bandwidth value and see how the residual changes, with the aim of minimising it. library(spgwr) # Load package ## NOTE: This package does not constitute approval of GWR ## as a method of spatial analysis; see example(gwr) fixed_bandwidth &lt;- gwr.sel(percent_second_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + pop_density, data = lad_eng, coords = cbind(lad_eng$long, lad_eng$lat), adapt = FALSE, method = &quot;cv&quot;, longlat = TRUE) # Select best fixed bandwidth for GWR (can be slow) ## Bandwidth: 307.6284 CV score: 2247.438 ## Bandwidth: 497.2562 CV score: 2262.816 ## Bandwidth: 190.4319 CV score: 2214.023 ## Bandwidth: 118.0005 CV score: 2122.952 ## Bandwidth: 73.23547 CV score: 1992.08 ## Bandwidth: 45.56914 CV score: 1916.536 ## Bandwidth: 28.47041 CV score: 2227.318 ## Bandwidth: 56.13674 CV score: 1935.575 ## Bandwidth: 34.26881 CV score: 1958.648 ## Bandwidth: 47.28953 CV score: 1916.081 ## Bandwidth: 46.99495 CV score: 1916.017 ## Bandwidth: 46.81922 CV score: 1916.005 ## Bandwidth: 46.81148 CV score: 1916.005 ## Bandwidth: 46.81257 CV score: 1916.005 ## Bandwidth: 46.81261 CV score: 1916.005 ## Bandwidth: 46.81253 CV score: 1916.005 ## Bandwidth: 46.81257 CV score: 1916.005 fixed_bandwidth ## [1] 46.81257 The output prints details of the model fitting process, but you can switch this off by adding verbose = FALSE. The optimised bandwidth for our model is 46.8125698 kilometers (km). The value suggests that a fixed radius of this distance is set and placed around each data point (area). Let’s repeat the process, but this time estimate an adaptive bandwidth. This will be useful for comparing model fit later. adaptive_bandwidth &lt;- gwr.sel(percent_second_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + pop_density, data = lad_eng, coords = cbind(lad_eng$long, lad_eng$lat), adapt = TRUE, method = &quot;cv&quot;, longlat = TRUE, verbose = TRUE) # Select best adaptive bandwidth for GWR (can be slow) ## Adaptive q: 0.381966 CV score: 2125.007 ## Adaptive q: 0.618034 CV score: 2211.108 ## Adaptive q: 0.236068 CV score: 2016.777 ## Adaptive q: 0.145898 CV score: 1964.669 ## Adaptive q: 0.09016994 CV score: 1900.774 ## Adaptive q: 0.05572809 CV score: 1837.333 ## Adaptive q: 0.03444185 CV score: 1760.934 ## Adaptive q: 0.02128624 CV score: 1691.024 ## Adaptive q: 0.01315562 CV score: 1797.949 ## Adaptive q: 0.02480104 CV score: 1712.084 ## Adaptive q: 0.01818062 CV score: 1718.198 ## Adaptive q: 0.02169819 CV score: 1689.364 ## Adaptive q: 0.02211599 CV score: 1688.373 ## Adaptive q: 0.02314159 CV score: 1696.927 ## Adaptive q: 0.02250172 CV score: 1691.397 ## Adaptive q: 0.0220753 CV score: 1688.142 ## Adaptive q: 0.02196273 CV score: 1688.48 ## Adaptive q: 0.0220323 CV score: 1688.268 ## Adaptive q: 0.0220753 CV score: 1688.142 adaptive_bandwidth ## [1] 0.0220753 Here the value of 0.0220753 presents the optimal proportion of neighbours (or k-nearest neighbours) to select as the bandwidth. In this example, we should select 2.2075297% of areas surrounding each data point (or nearest neighbours), or equivalent to selecting nrow(lad_eng) * adaptive_bandwidth areas around each data point each time we run a regression. 4.3 Running the model Now that we are ready to fit our GWR model, there are two key areas we need to concentrate on when interpreting any GWR model: (i) model fit, and (ii) the meaning of spatially varying coefficients. 4.3.1 Assessing model fit We have so far two types of bandwidth to use in fitting our GWR model. We need to identify which we will use for reporting our results. To make a decision, we will fit two GWR models, one for each of the two bandwidths, and compare their model fits to see which performs better. # Model with fixed bandwidth model2_fixed &lt;- gwr(percent_second_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + pop_density, data = lad_eng, coords = cbind(lad_eng$long, lad_eng$lat), bandwidth = fixed_bandwidth, hatmatrix = TRUE, se.fit = TRUE, longlat = TRUE) # Model with adaptive bandwidth model2_adapt &lt;- gwr(percent_second_dose ~ median_age + Other_White + Mixed + Black + Asian + Other + mean_imd_score + pop_density, data = lad_eng, coords = cbind(lad_eng$long, lad_eng$lat), adapt = adaptive_bandwidth, hatmatrix = TRUE, se.fit = TRUE, longlat = TRUE) # note we use adapt for the bandwidth here Let’s compare the overall model fit for both of these models. We will just look at the corrected AIC values model2_fixed$results$AICh # AIC - fixed bandwidth ## [1] 1348.313 model2_adapt$results$AICh # AIC - adaptive bandwidth ## [1] 1246.369 # model2_fixed$results$AICb # AIC corrected for small sample sizes - fixed bandwidth # model2_adapt$results$AICb # AIC corrected for small sample sizes - adaptive bandwidth The adaptive bandwidth model has better fit (lower value) and therefore may be preferable on this statistic. We will next compare the compare the range of local r2 values, to assess model fit performance of our regression models.. summary(model2_fixed$SDF$localR2) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.6948 0.9080 0.9268 0.9249 0.9409 0.9999 summary(model2_adapt$SDF$localR2) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 0.8521 0.9513 0.9664 0.9607 0.9733 0.9925 Mean and median R2 is higher with the adaptive bandwidth selected, suggesting that on average each areas model fit is better here. If we look at the minimum values, model fit is poorer for the fixed bandwidth as well suggesting the model does less well in particular areas. Next, we compare the local model fit values to see if one of the models is under/over-performing in particular parts of England. This can give us clues towards whether there are geographical issues in model fit. For example, the use of fixed bandwidths can often lead to too many dissimilar data points selected in regression models (leading to poorer fitting models), or too few data points leading to large uncertainty in estimates. Adaptive bandwidths may vary in their performance spatially given their different sizes of bandwidths. First, we plot the local R^2 values for the fixed bandwidth model. # Tidy data results_fixed &lt;- as.data.frame(model2_fixed$SDF) # Save coefficients lad_eng$fixed_r2 &lt;- results_fixed$localR2 # Add local r2 value to data for mapping # Plot map2 &lt;- ggplot() + # Call ggplot command geom_sf(data = lad_eng, aes(fill = fixed_r2), lwd = 0) + # Define what to plot scale_fill_viridis(limits = c(0, 1)) + # Make colourblind friendly (and set limits to plot for consistency) xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Local model fit (fixed bandwidth)&quot;, # Edit plot title fill = &quot;R2 value&quot;) # Edit legend title map2 # Print plot Model fit looks good, but with poorer fit in the North West of England (e.g., Cumbria). Let’s repeat this for the adaptive bandwidth model. # Tidy data results_adapt &lt;- as.data.frame(model2_adapt$SDF) # Save coefficients lad_eng$adapt_r2 &lt;- results_adapt$localR2 # Add local r2 value to data for mapping # Plot map3 &lt;- ggplot() + # Call ggplot command geom_sf(data = lad_eng, aes(fill = adapt_r2), lwd = 0) + # Define what to plot scale_fill_viridis(limits = c(0, 1)) + # Make colourblind friendly (and set limits to plot for consistency) xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Local model fit (adaptive bandwidth)&quot;, # Edit plot title fill = &quot;R2 value&quot;) # Edit legend title map3 # Print plot There is some poorer fit in the Northern England and in Cornwall, but otherwise it looks fairly good. In sum, both of the models are very good. For the purposes of this tutorial, we will use the adaptive bandwidth since it generally has better model fit. 4.3.2 Plotting coefficients Let’s begin through looking at our overall summary of our analytical model. We can print out the raw output just by running the object in R. I don’t know of a way of cleaning this into a nice and tidy table sorry, not sorry. model2_fixed ## Call: ## gwr(formula = percent_second_dose ~ median_age + Other_White + ## Mixed + Black + Asian + Other + mean_imd_score + pop_density, ## data = lad_eng, coords = cbind(lad_eng$long, lad_eng$lat), ## bandwidth = fixed_bandwidth, hatmatrix = TRUE, longlat = TRUE, ## se.fit = TRUE) ## Kernel function: gwr.Gauss ## Fixed bandwidth: 46.81257 ## Summary of GWR coefficient estimates at data points: ## Min. 1st Qu. Median 3rd Qu. Max. Global ## X.Intercept. -2.4903e+01 -9.1887e-01 3.0533e+00 7.3111e+00 1.3355e+02 4.7973 ## median_age -1.1969e+00 9.7545e-01 1.0405e+00 1.1616e+00 1.6200e+00 1.0410 ## Other_White -3.3888e-01 -1.7318e-01 -1.6598e-02 7.1306e-02 7.6619e-01 -0.1071 ## Mixed -6.5502e-01 1.0532e-02 3.6080e-01 4.9383e-01 4.1734e+00 0.1229 ## Black -1.8214e+01 -4.1662e-01 -2.3640e-01 -1.3846e-01 -6.8347e-03 -0.1811 ## Asian -5.2151e+00 -7.6231e-02 -7.4432e-03 5.8227e-03 6.5581e-02 -0.0260 ## Other -9.0439e+00 -1.8882e-01 -1.0064e-01 1.1253e-01 3.0705e+00 -0.1225 ## mean_imd_score -7.8441e-01 -5.0281e-02 1.0860e-02 6.3091e-02 2.0162e-01 0.0205 ## pop_density -7.9592e-04 -7.3941e-04 -5.5343e-05 2.9945e-04 7.5985e-03 -0.0004 ## Number of data points: 317 ## Effective number of parameters (residual: 2traceS - traceS&#39;S): 94.59721 ## Effective degrees of freedom (residual: 2traceS - traceS&#39;S): 222.4028 ## Sigma (residual: 2traceS - traceS&#39;S): 2.160288 ## Effective number of parameters (model: traceS): 72.72148 ## Effective degrees of freedom (model: traceS): 244.2785 ## Sigma (model: traceS): 2.06129 ## Sigma (ML): 1.809473 ## AICc (GWR p. 61, eq 2.33; p. 96, eq. 4.21): 1468.508 ## AIC (GWR p. 96, eq. 4.22): 1348.313 ## Residual sum of squares: 1037.919 ## Quasi-global R2: 0.9411265 There is a lot of output and information here. Let’s just focus on the summary of the GWR coefficients, which is typically what would be reported in a report. The table presents summary statistics for the coefficients in the model (each coefficient is a row) across all of the local regressions (in our case, all 317 regression models). We may be interested in the minimum and maximum values to see what the range of values are (which is a useful first step to see if coefficients vary in direction). The global model is the same as OLS coefficients and is a useful point of reference to compare to estimates generated in the GWR model. The 1st Quartile, Median and 3rd Quartile values are also useful for considering the variation in values in terms of direction of association and magnitude of strength. The next step will be to visualise the spatial variations in coefficient values. This will allow us to see if there are any distinct geographical patterns in relationships. We will just plot for the variable IMD score (deprivation). First, let’s plot the coefficient values. # Get data lad_eng$imd_coef &lt;- model2_fixed$SDF$mean_imd_score # Coefficients # Plot map4 &lt;- ggplot() + # Call ggplot command geom_sf(data = lad_eng, aes(fill = imd_coef), lwd = 0) + # Define what to plot scale_fill_viridis() + # Make colourblind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Deprivation&quot;, # Edit plot title fill = &quot;Coefficient&quot;) # Edit legend title map4 # Print plot We may also want to plot the standard errors to look at the variability in the precision of our coefficient estimates. # Get data lad_eng$imd_coef_se &lt;- model2_fixed$SDF$mean_imd_score_se # Standard error # Plot map5 &lt;- ggplot() + # Call ggplot command geom_sf(data = lad_eng, aes(fill = imd_coef_se), lwd = 0) + # Define what to plot scale_fill_viridis() + # Make colourblind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Deprivation&quot;, # Edit plot title fill = &quot;Standard Error&quot;) # Edit legend title map5 # Print plot The next step would be to assess the statistical significance of the coefficients to identify if any associations were meaningful. To do this, we estimate the t-value and then categorise observations if they meet 95% level of significance. Let’s plot areas based on whether they meet the criterion. # Calculate t statistic lad_eng$t_imd_coef = results_fixed$mean_imd_score / results_fixed$mean_imd_score_se # Categorise t values as significant or not lad_eng$t_imd_coef_cat &lt;- cut(lad_eng$t_imd_coef, breaks=c(min(lad_eng$t_imd_coef), -2, 2, max(lad_eng$t_imd_coef)), labels=c(&quot;Sig.&quot;,&quot;Non-sig.&quot;, &quot;Sig.&quot;)) # Plot map6 &lt;- ggplot() + # Call ggplot command geom_sf(data = lad_eng, aes(fill = t_imd_coef_cat), lwd = 0) + # Define what to plot scale_fill_viridis_d() + # Make colourblind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Deprivation&quot;, # Edit plot title fill = &quot;Statistical significance&quot;) # Edit legend title map6 # Print plot It may be useful to combine the coefficient and statistical significance plots into one single visualisation. You could do this by joining the two plots together side-by-side using a R package like patchwork. Rather, we will only plot significant associations and hide those which are not. # Plot map7 &lt;- ggplot() + # Call ggplot command geom_sf(data = lad_eng, lwd = 0) + # Plot all areas as base layer geom_sf(data = lad_eng[lad_eng$t_imd_coef_cat == &quot;Sig.&quot;,], aes(fill = imd_coef), lwd = 0) + # Plot the coefficients that are significant scale_fill_viridis() + # Make colourblind friendly xlab(&quot;Longitude&quot;) + # Add x-axis label ylab(&quot;Latitude&quot;) + # Add y-axis label labs(title = &quot;Deprivation&quot;, # Edit plot title fill = &quot;Coefficient&quot;) # Edit legend title map7 # Print plot Why not have a look at other coefficients now - what can you find out? What interesting spatial patterns are there? 4.4 Scaling GWR for large datasets GWR models are computationally intensive to fit and therefore do not scale well with larger datasets (even those with 10000+ observations can be demanding). Some clever cookies have adapted the methodology to estimate the model quicker when dealing with larger or more complex datasets, including creating the R package scgwr (SCalable GWR) to implement the method in R. You can read more about the methodology here. The actual code is not too difficult to use, but may require some refinement to model parameters. Specifically, we may want to play about with: knn - Number of nearest-neighbours selected during estimation: larger is better for bigger datasets. nsamp - Number of random samples for (aproximate) cross-validation: should be smaller than sample size, but larger is better for minimising errors due to random sampling. Let’s re-run the model again, but using the scgwr package. Unfortunately, this code does not work with our example so I leave it in here to show the option for you in case you ever need it. If you can fix it, please send in your answers on a postcode. # # Library # library(scgwr) # # # Tidy data # outcome &lt;- lad_eng[, &quot;percent_second_dose&quot;] # Store outcome variable (if don&#39;t define as object then stores as list) # xvars &lt;- lad_eng[, c(&quot;median_age&quot;, &quot;Other_White&quot;, &quot;Mixed&quot;, &quot;Black&quot;, &quot;Asian&quot;, &quot;Other&quot;, &quot;mean_imd_score&quot;, &quot;pop_density&quot;)] # Store explanatory variables # xy &lt;- lad_eng[, c(&quot;long&quot;, &quot;lat&quot;)] # Store co-ordinates # # # Model # model3 &lt;- scgwr(y = outcome, x = xvars, coords = xy, knn = 100, kernel = &quot;gau&quot;, p = 4, approach = &quot;CV&quot;) # Model using cross-validation approach (&quot;CV&quot;) and Gaussian kernel (&quot;gau&quot;) The R package can incorporate parallel processing for faster processing as well using the scgwr_p command. 4.5 Summary In this practical session, we have explored how use Geographically Weighted Regression and explored the opportunities that it can bring for exploring spatially varying contexts. "],["summary.html", "Chapter 5 Summary 5.1 Learning outcomes 5.2 Further learning 5.3 Thank you", " Chapter 5 Summary Well done on making it to the end! Before we sign off, it is a good time to reflect over everything you have achieved over the past few weeks. 5.1 Learning outcomes Let’s review how you have achieved each of the learning outcomes for this section of the module. Produce static and interactive visualisations of spatial data. In the first session, you learned how to load spatial data into R and map the data using a variety of packages. You produced different types of maps, including how to present them effectively or make maps interactive. Identify clustering of point- and area-based data. Our second session looked at how we might try to identify spatial clusters for data. First, descriptive techniques were applied on point-based data. Second, using area-based data you calculated spatial weights and looked for clusters using Moran’s I approaches. Extend regression-based approaches to incorporate spatial context. The final learning outcome was achieved through two sessions. First, we extended OLS regression approaches using spatially lagged variables or accounted for the spatial structure of error terms to accommodate spatial regression techniques. Second, we extended OLS regression approaches to incorporate spatially varying coefficients through Geographically Weighted Regression. 5.2 Further learning The methods we have covered so far will have given you a good grounding in spatial methods, however they are just a small flavour of the vast range of opportunities thinking spatially can bring to research. Here are a few other areas or methods you can read up on in case you want to take things forward. For each, I have provided a (open access) research example of its application and some example R code/packages for you to see how it can be done. Cartograms -&gt; Description: Maps can lie. They can distort patterns, resulting in the misleading interpretation of data. One distortion comes from the geographical size of zones. Where zones are small they can be hard to see, and hence larger areas may attract your attention. You may have noticed this in the spatial regression session when some cities were difficult to see on the maps. Cartograms (including linked methods for distorting area sizes such as hexmaps) offer one way of minimising this bias, through readjusting the geographical sizes of areas based on their underlying population sizes. This can allow for fairer comparisons, especially when mapping people rather than places. Research example: Worldmapper: The Human Anatomy of a Small Planet. R example: Tutorial using ggplot2. Spatial panel model -&gt; Description: The spatial regression models we have introduced are cross-sectional (i.e., a single point in time) and can not account for the longitudinal nature of datasets (i.e., where we have repeated data points over time for each area). These models can be extended longitudinally, similar to how we might extend the classical regression model to incorporate time, to give stronger tests of associations between predictors and outcomes. Research example: Determining the spatial effects of COVID-19 using the spatial panel data model. R example: Package spml. Spatial multi-level -&gt; Description: Multi-level modelling revolutionised health geography, since through nesting individuals within areas you could control for individual level characteristics and, in theory, separate out differences which difference between areas can explain. While these methods are powerful, they do not explicitly account for space since the model does not which areas are located where. There exists spatial extensions to multi-level models. Research example: Methodological paper extending multi-level models to incoporate spatial effects. R example: HSAR package. Spatial interaction models and flow data -&gt; Description: Flow data are not frequently found in spatial health research. They refer to where we have observations of spatial interactions between two places. The most common application might be movement data (e.g., in- and out-migration flows between two places). Spatial interaction models extend these data and organise them into a regression framework, that can model the interactions between places to understand what may drive them. Research example: Using a Spatial Interaction Model to Assess the Accessibility of District Parks in Hong Kong. R example: Spatial Interaction Models for Dummies. Location-allocation -&gt; Description: Where we have spatial points representing sites/locations (e.g., health services), we can try to geographically optimise the locations of sites to improve geographical coverage. This can be useful for locating new site locations, including finding where it is best to place new sites to maximise coverage in areas with low access. Research example: Evaluating the locations of asymptomatic COVID-19 test sites in Liverpool. R example: Replicatable code from research example. Bayesian extensions -&gt; Description: Bayesian models offer an alternative approach to analysis than frequentist methods. There are a lot of different spatial extensions to Bayesian models, allowing for more flexibility to how we approach our analyses. These approaches are important if we want to utilise generalised linear models. Research example: Evaluating social and spatial inequalities in COVID-19 testing in Liverpool. R example: Geospatial Health Data Book. Causal inference methods -&gt; Description: There are a large number of techniques that have tried to implement causal inference approaches within a spatial framework. One example of these methods might be spatial regression discontinuity approaches, where you assess impacts of interventions in places through comparisons to the impacts closest to them where they were not implemented. Research example: Review of spatial causal inference methods. R example: SpatialRDD package. Spatial machine learning -&gt; Description: A relatively newer area of research explores how we can extend machine learning methods to explicitly incorporate space into them. This field is so new that I have very little to report here! Research example: Spatio-temporal predictions using deep learning. R example: Statistical Learning tutorial. 5.3 Thank you I would just like to end by thanking you for taking the time to read through these materials and hopefully you have enjoyed learning about spatial data analysis. If you have any further questions, please do not hesitate to get in contact. Dr Mark A. Green Senior Lecturer in Health Geography University of Liverpool mark.green@liverpool.ac.uk "],["references.html", "References", " References "]]
